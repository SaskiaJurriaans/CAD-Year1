---
title: "YEAR1 Size"
author: "Sas"
format: html
editor: visual
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "C:/Users/sjurriaa/Australian Institute of Marine Science/Carly Randall - Randall Lab/CAD/CAD Year1")
```

------------------------------------------------------------------------

# Preparations

Load the necessary libraries

```{r}
#| label: libraries
#| output: false
#| eval: true
#| warning: false
#| message: false
#| cache: false

library(tidyverse)  #for data wrangling etc
library(rstanarm)   #for fitting models in STAN
#library(cmdstanr)   #for cmdstan --> does not work on AIMS computers
library(brms)       #for fitting models in STAN
library(standist)   #for exploring distributions
library(coda)       #for diagnostics
library(bayesplot)  #for diagnostics
library(ggmcmc)     #for MCMC diagnostics
library(DHARMa)     #for residual diagnostics
library(rstan)      #for interfacing with STAN
library(emmeans)    #for marginal means etc
library(broom)      #for tidying outputs
library(tidybayes)  #for more tidying outputs
library(HDInterval) #for HPD intervals
library(ggeffects)  #for partial plots
library(broom.mixed)#for summarising models
library(posterior)  #for posterior draws
library(ggeffects)  #for partial effects plots
library(patchwork)  #for multi-panel figures
library(bayestestR) #for ROPE
library(see)        #for some plots
library(readxl)     #to load excel documents
library(easystats)     #framework for stats, modelling and visualisation
#library(INLA)       #for approximate Bayes
library(openxlsx)    # to write excel documents
#library(INLAutils)  #for additional INLA outputs
theme_set(theme_grey()) #put the default ggplot theme back
library(lme4)
library(gridExtra)
library(gtable)
library(grid)
library(egg)
#source('helperFunctions.R')
```

# Read in the data

```{r}
#| label: import data
#| warning: false
#| message: false
survival <- read_excel("data/YEAR1_Survival.xlsx", 
    col_types = c("numeric", "skip", "text", 
        "skip", "skip", "numeric", "skip", 
        "text", "text", "numeric", "skip", 
        "text", "numeric", "text", "numeric", 
        "numeric", "numeric", "numeric", 
        "numeric"), na = "na")

environment <- read_excel ("data/YEAR1 Benthic Environment ReefDev.xlsx", na="na")
```

# Data tidying

**Create new column for size and remove empty rows with no size data**

```{r}
#| label: mutate survival
survival_size <- survival |>
  mutate(Size = (LinLength_mm * PerpLenght_mm * Height_mm)/1000,
         Size_log = log(Size + 1)) # Adding 1 to avoid log(0) 
```

**Separate by Reef**

Moore:

```{r}
#| label: filter moore
moore_surv <- survival_size |> filter (Reef == "Moore",
                                  Census =="t6")  
moore_env <- environment |> 
  filter (Reef == "Moore") |>
  select(-c(Reef1, Device_ID))
```

Davies:

```{r}
#| label: filter davies
davies_surv <- survival_size |> filter (Reef == "Davies",
                                   Census == "t6") 

davies_env <- environment |> 
  filter (Reef == "Davies") |>
  select(-c(Reef1, Device_ID))
```

Heron:

```{r}
heron_surv <- survival_size |> filter (Reef == "Heron",
                                  Census == "t3") 

heron_env <- environment |> 
  filter (Reef == "Heron") |>
  select(-c(Reef1, Device_ID))
```

**Merge survival and environment**

```{r}
moore <- merge(moore_env, moore_surv, by = c("Reef", "Site", "ReefDev"), all = TRUE)
davies <- merge(davies_env, davies_surv, by = c("Reef", "Site", "ReefDev"), all = TRUE)
heron <- merge(heron_env, heron_surv, by = c("Reef", "Site", "ReefDev"), all = TRUE)
```

**Free up space**

```{r}
#free up space
remove(moore_surv, moore_env)
remove(davies_surv, davies_env)
remove(heron_surv, heron_env)
remove(survival_size)
```

**Remove rows with missing values**

Moore:

```{r}
moore$SurvDev <- as.numeric(moore$SurvDev)
moore <- moore[complete.cases(moore$Size),  ]
```

Davies:

```{r}
davies$SurvDev <- as.numeric(davies$SurvDev)
davies <- davies[complete.cases(davies$Size),  ]
```

Heron:

```{r}
heron$SurvDev <- as.numeric(heron$SurvDev)
heron <- heron[complete.cases(heron$Size),  ]
```

Fill in missing values for the environmental variables (since they are the same for each device within a site). However, not PC1 and PC2 values, these are device specific (because community composition was identified around each specific device), thus missing values of PC1 and PC2 cannot be filled in and need to be removed from analyses when running regressions for habitat.

Moore:

```{r}
moore <- moore |>
  group_by(Site) |>
  mutate(
    Ub_avrg = ifelse(is.na(Ub_avrg), max(Ub_avrg, na.rm=TRUE), Ub_avrg),
    median_speed = ifelse(is.na(median_speed), max(median_speed, na.rm = TRUE), median_speed),
    percentile_10 =  ifelse(is.na(percentile_10), max(percentile_10, na.rm = TRUE), percentile_10),
    percentile_90 =  ifelse(is.na(percentile_90), max(percentile_90, na.rm = TRUE), percentile_90),
    range  =  ifelse(is.na(range), max(range, na.rm = TRUE), range),
    mean_temp = ifelse(is.na(mean_temp), max(mean_temp, na.rm = TRUE), mean_temp),
    sedturf_t5 = ifelse(is.na(sedturf_t5), max(sedturf_t5, na.rm = TRUE), sedturf_t5),
    sedconcrete_t5 = ifelse(is.na(sedconcrete_t5), max(sedconcrete_t5, na.rm = TRUE), sedconcrete_t5)
      ) |>
  ungroup()
```

Davies:

```{r}
davies <- davies |>
  group_by(Site) |>
  mutate(
    Ub_avrg = ifelse(is.na(Ub_avrg), max(Ub_avrg, na.rm=TRUE), Ub_avrg),
    median_speed = ifelse(is.na(median_speed), max(median_speed, na.rm = TRUE), median_speed),
    percentile_10 =  ifelse(is.na(percentile_10), max(percentile_10, na.rm = TRUE), percentile_10),
    percentile_90 =  ifelse(is.na(percentile_90), max(percentile_90, na.rm = TRUE), percentile_90),
    range  =  ifelse(is.na(range), max(range, na.rm = TRUE), range),
    mean_temp = ifelse(is.na(mean_temp), max(mean_temp, na.rm = TRUE), mean_temp),
    sedturf_t2 = ifelse(is.na(sedturf_t2), max(sedturf_t2, na.rm = TRUE), sedturf_t2),
    sedconcrete_t2 = ifelse(is.na(sedconcrete_t2), max(sedconcrete_t2, na.rm = TRUE), sedconcrete_t2),
    sedturf_t5 = ifelse(is.na(sedturf_t5), max(sedturf_t5, na.rm = TRUE), sedturf_t5),
    sedconcrete_t5 = ifelse(is.na(sedconcrete_t5), max(sedconcrete_t5, na.rm = TRUE), sedconcrete_t5)
    ) |>
  ungroup()

davies <- davies |> 
  group_by(Site) |>
  mutate(sedturf = ((sedturf_t2+sedturf_t5)/2),
         sedconcrete = ((sedconcrete_t2+sedconcrete_t5)/2)
         ) |>
  select(-c(sedturf_t2, sedturf_t5, sedconcrete_t2, sedconcrete_t5))


  
```

Heron:

```{r}
heron <- heron |>
  group_by(Site) |>
  mutate(
    Ub_avrg = ifelse(is.na(Ub_avrg), max(Ub_avrg, na.rm=TRUE), Ub_avrg),
    median_speed = ifelse(is.na(median_speed), max(median_speed, na.rm = TRUE), median_speed),
    percentile_10 =  ifelse(is.na(percentile_10), max(percentile_10, na.rm = TRUE), percentile_10),
    percentile_90 =  ifelse(is.na(percentile_90), max(percentile_90, na.rm = TRUE), percentile_90),
    sedturf_t2 = ifelse(is.na(sedturf_t2), max(sedturf_t2, na.rm = TRUE), sedturf_t2),
    sedconcrete_t2 = ifelse(is.na(sedconcrete_t2), max(sedconcrete_t2, na.rm = TRUE), sedconcrete_t2),
    range  =  ifelse(is.na(range), max(range, na.rm = TRUE), range),
    mean_temp = ifelse(is.na(mean_temp), max(mean_temp, na.rm = TRUE), mean_temp)
    ) |>
  ungroup()
```

# \-\-\-\-\-\-\-\-\-\-\-\-- GLM -------------------

# Moore

Make Site and ReefDev (id) as factors

```{r}
moore$Site <- as.factor(moore$Site)
moore$ReefDev<- as.factor(moore$ReefDev)
```

Cut median speed in bins to make it a factor

```{r}
# Decide on the number of bins
num_bins <- 10  # You can adjust this number based on your needs

# Convert median_speed to a categorical variable using cut
moore$median_speed_cat <- cut(moore$median_speed, breaks = num_bins, labels = FALSE)
moore$median_speed_cat <- as.factor(moore$median_speed_cat)

# Check the result
table(moore$median_speed_cat)
```

Models with random effects Site and/or ReefDev

```{r}
moore_lmer1a <- lmer(Size_log ~ (1|Site), data=moore)
moore_lmer1b <- lmer(Size_log ~ (1|ReefDev), data=moore)
moore_lmer1c <- lmer(Size_log ~ (1|Site) + (1|ReefDev), data=moore)
moore_lmer_nested <- lmer(Size_log ~ (1 | Site / ReefDev), data = moore)

AIC(moore_lmer1a, moore_lmer1b, moore_lmer1c, moore_lmer_nested)

summary(moore_lmer1a)
summary(moore_lmer1b)
summary(moore_lmer1c)
summary(moore_lmer_nested)
```

Conclusion: keep both reefdev and site in model as random effects - use nested hierarchical structure to account for variability between sites and devices nested within sites

```{r}
moore_lmer2 <- lmer(Size_log ~ Ub_avrg + (1 | Site / ReefDev), data=moore)
moore_lmer3 <- lmer(Size_log ~ WaveEnergyLevel + (1 | Site / ReefDev), data=moore) 
moore_lmer4 <- lmer(Size_log ~ median_speed + (1 | Site / ReefDev), data=moore)
moore_lmer4cat <- lmer(Size_log ~ median_speed_cat + (1 | Site / ReefDev), data=moore)
moore_lmer5 <- lmer(Size_log ~ sedturf_t5 + sedconcrete_t5 + (1 | Site / ReefDev), data=moore)
moore_lmer6 <- lmer(Size_log ~ sedturf_t5 + (1 | Site / ReefDev), data=moore)
moore_lmer7 <- lmer(Size_log ~ sedconcrete_t5 + (1 | Site / ReefDev), data=moore)
moore_lmer8 <- lmer(Size_log ~ PC1 + PC2 + (1 | Site / ReefDev), data=moore) 

summary(moore_lmer2)
summary(moore_lmer3)
summary(moore_lmer4)
summary(moore_lmer4cat)
summary(moore_lmer5)
summary(moore_lmer6)
summary(moore_lmer7)
summary(moore_lmer8)

AIC(moore_lmer1c, moore_lmer2, moore_lmer3, moore_lmer4,moore_lmer4cat, moore_lmer5, moore_lmer6, moore_lmer7, moore_lmer8)
```

```{r}
moore_long <- moore |>
  pivot_longer(cols = c(sedturf_t5, sedconcrete_t5), 
               names_to = "SedPod", 
               values_to = "Sedimentation")

moore_long$SedPod<- as.factor(moore_long$SedPod)

moore_lmer9 <- lmer(Size_log ~ SedPod * Sedimentation + (1|Site), data=moore_long)
moore_lmer10 <- lmer(Size_log ~ SedPod * Sedimentation + (1|ReefDev), data=moore_long)
moore_lmer11 <- lmer(Size_log ~ SedPod * Sedimentation + (1 | Site / ReefDev), data=moore_long)
#moore_lmer12 <- lmer(Size_log ~ SedPod * Sedimentation + (ReefDev|Site), data=moore_long)
#moore_lmer13 <- lmer(Size_log ~ SedPod * Sedimentation + (Site|ReefDev), data=moore_long)

summary(moore_lmer9)
summary(moore_lmer10)
summary(moore_lmer11)

AIC(moore_lmer9, moore_lmer10, moore_lmer11)
```

**Conclusion**: keep turf and concrete as fixed effects in separate models, with hierarchical structure of devices nested within site.

Vizualize lmer using Size as predictor

```{r}
#plot with raw data
ggplot(data=moore, aes(y = Size, x = median_speed)) + 
  geom_point()+
  geom_smooth(method="lm")

#plot with raw data and poly smoothner
ggplot(data=moore, aes(y = Size, x = median_speed)) + 
  geom_point()+
   geom_smooth(method="lm", formula = y~poly(x,3), se = FALSE)

#plot with speed as categorical data
ggplot(data=moore, aes(y = Size, x = median_speed_cat)) + 
  geom_point()

#plot wiht speed log transformed
ggplot(data=moore, aes(y = Size_log, x = median_speed)) + 
  geom_point()+
   geom_smooth(method="lm")
```

Calculate marginal means

```{r}
library(emmeans)
marginal_means<- emmeans(moore_lmer4, ~median_speed)
marginal_means_df <- as.data.frame(marginal_means)

head(marginal_means_df)
```

Calculate marginal means for the categorical variable

```{r}
marginal_means_cat <- emmeans(moore_lmer4cat, ~ median_speed_cat)
marginal_means_cat_df <- as.data.frame(marginal_means_cat)

# Inspect the marginal means dataframe
head(marginal_means_cat_df)

```

Calculate marginal means for log transformed response variable

```{r}
marginal_means_log<- emmeans(moore_lmer4, ~median_speed)
marginal_means_log_df <- as.data.frame(marginal_means)

head(marginal_means_df)
```

Vizualize marginal means with median speed as a continuous variable

```{r}
# Plot raw data with marginal means - RAW DATA SCALE
ggplot() +
  geom_point(data = moore, aes(x = median_speed, y = Size)) +
  geom_line(data = marginal_means_df, aes(x = median_speed, y = emmean, group = 1), size = 1) +
  geom_pointrange(data = marginal_means_df, aes(x = median_speed, y = emmean, ymin = lower.CL, ymax = upper.CL), size = 1, color = "blue") +
  labs(title = "Raw Data and Marginal Means: Size vs. Median Speed - continuous ",
       x = "Median Flow velocity (m/s)",
       y = "Size") +
  theme_modern()

# Plot raw data with marginal means - LOG TRANSFORMED SCALE
ggplot() +
  geom_point(data = moore, aes(x = median_speed, y = Size_log), alpha = 0.3) +
  geom_line(data = marginal_means_log_df, aes(x = median_speed, y = emmean, group = 1), size = 1) +
  geom_pointrange(data = marginal_means_log_df, aes(x = median_speed, y = emmean, ymin = lower.CL, ymax = upper.CL), size = 1, color = "blue") +
  labs(title = "Raw Data and Marginal Means: Log(Size) vs. Median Speed (Continuous)",
       x = "Median Flow velocity (m/s)",
       y = "log(Size)") +
  theme_modern()

```

And with median speed as a categorical variable

```{r}
# Plot raw data with marginal means and confidence intervals for categorical variable
ggplot() +
  geom_point(data = moore, aes(x = median_speed_cat, y = Size_log), alpha = 0.3) +  # Raw data points with transparency
  geom_line(data = marginal_means_cat_df, aes(x = median_speed_cat, y = emmean, group = 1), color = "blue", size = 1) +
  geom_errorbar(data = marginal_means_cat_df, aes(x = median_speed_cat, ymin = lower.CL, ymax = upper.CL), width = 0.2, color = "blue") +
  theme_minimal() +
  labs(title = "Raw Data and Marginal Means: Size (log) vs. Median Speed (Categorical)",
       x = "Median Speed (Categorical)",
       y = "Size log transformed") +
  theme_modern()
```

# Davies

Make Site and ReefDev (id) as factors

```{r}
davies$Site <- as.factor(davies$Site) 
davies$ReefDev<- as.factor(davies$ReefDev)
```

Cut median speed in bins to make it a factor

```{r}
# Decide on the number of bins 
num_bins <- 10

# Convert median_speed to a categorical variable using cut 
davies$median_speed_cat <- cut(davies$median_speed, breaks = num_bins, labels = FALSE) 
davies$median_speed_cat <- as.factor(davies$median_speed_cat)  

# Check the result 
table(davies$median_speed_cat)
```

```{r}
#models with random effects Site and/or ReefDev
davies_lmer1a <- lmer(Size_log ~ (1|Site), data=davies) 
davies_lmer1b <- lmer(Size_log ~ (1|ReefDev), data=davies) 
davies_lmer1c <- lmer(Size_log ~ (1|ReefDev)+ (1|Site), data=davies)
davies_lmer_fixed <- lmer(Size_log ~ (1|ReefDev) + Site, data=davies)
davies_lmer_nested <- lmer(Size_log ~ (1 | Site / ReefDev), data = davies)

AIC(davies_lmer1a, davies_lmer1b, davies_lmer1c, davies_lmer_fixed,davies_lmer_nested)
```

**Conclusion**: [ReefDev as random effect]{.underline} is better than Site as random effect, but for our research questions we want to keep site in the model thus moving forward with [**(1\|Site / ReefDev)**]{.underline} because this will tell me how much variability in size_log is due to differences between sites and due to differences between devices within the same site.

```{r}
#models with environmental predictors with Site as random effect
davies_lmer2 <- lmer(Size_log ~ Ub_avrg + (1 | Site / ReefDev), data=davies) 
davies_lmer3 <- lmer(Size_log ~ WaveEnergyLevel + (1|Site/ ReefDev), data=davies)  
davies_lmer4 <- lmer(Size_log ~ median_speed + (1|Site/ ReefDev), data=davies) 
davies_lmer4cat <- lmer(Size_log ~ median_speed_cat + (1|Site/ ReefDev), data=davies) 

davies_lmer5 <- lmer(Size_log ~ sedturf_t2 + sedconcrete_t2 + (1|Site/ ReefDev), data=davies) 
davies_lmer5d <- lmer(Size_log ~ sedturf_t2 +  (1|Site/ ReefDev), data=davies)  
davies_lmer5e <- lmer(Size_log ~  sedconcrete_t2 + (1|Site/ ReefDev), data=davies) 

davies_lmer6 <- lmer(Size_log ~ sedturf_t5 + sedconcrete_t5 + (1|Site/ ReefDev), data=davies) 
davies_lmer6d <- lmer(Size_log ~ sedturf_t5 + (1|Site/ ReefDev), data=davies) 
davies_lmer6e <- lmer(Size_log ~ sedconcrete_t5 + (1|Site/ ReefDev), data=davies) 

davies_lmer7 <- lmer(Size_log ~ sedturf_t2 + sedconcrete_t2 + sedturf_t5 + sedconcrete_t5 + (1|Site/ ReefDev), data=davies) 
AIC(davies_lmer2, davies_lmer3, davies_lmer4,davies_lmer4cat, davies_lmer5,davies_lmer5d, davies_lmer5e, davies_lmer6,davies_lmer6d, davies_lmer6e, davies_lmer7)

summary(davies_lmer2) 
summary(davies_lmer3) 
summary(davies_lmer4) 
summary(davies_lmer4cat) 
summary(davies_lmer5)  
summary(davies_lmer6)  
summary(davies_lmer7)
```

**Conclusion: models are better with sedturf and sedconcrete as fixed effects in separate models**

Lastly, check GLMs with Sedimentation as a [factor]{.underline} instead of fixed effects

```{r}
davies_long <- davies |>
  pivot_longer(cols = c(sedturf_t2, sedconcrete_t2,sedturf_t5, sedconcrete_t5), 
               names_to = "SedPod", 
               values_to = "Sedimentation")

davies_long$SedPod<- as.factor(davies_long$SedPod)

davies_lmer8 <- lmer(Size_log ~ SedPod * Sedimentation + (1|Site), data=davies_long)
davies_lmer9 <- lmer(Size_log ~ SedPod * Sedimentation + (1|ReefDev), data=davies_long)
davies_lmer10 <- lmer(Size_log ~ SedPod * Sedimentation + (1|Site/ ReefDev), data=davies_long)
#davies_lmer11 <- lmer(Size_log ~ SedPod * Sedimentation + (ReefDev|Site), data=davies_long)
#davies_lmer12 <- lmer(Size_log ~ SedPod * Sedimentation + (Site|ReefDev), data=davies_long)

AIC(davies_lmer8, davies_lmer9, davies_lmer10)
```

**Conclusion:** models perform worse when sedimentation is a factor.

[**Moving forward:**]{.underline} **keep turf and concrete as fixed effects in separate models.**

Vizualize lmer using Size as predictor

```{r}
#plot with raw data 
ggplot(data=davies, aes(y = Size, x = median_speed)) +    
  geom_point()+   
  geom_smooth(method="lm")  

#plot with raw data and poly smoothner 
ggplot(data=davies, aes(y = Size, x = median_speed)) +    
  geom_point()+    
  geom_smooth(method="lm", formula = y~poly(x,3), se = FALSE)  

#plot with speed as categorical data 
ggplot(data=davies, aes(y = Size, x = median_speed_cat)) +    
  geom_point()  

#plot wiht speed log transformed 
ggplot(data=davies, aes(y = Size_log, x = median_speed)) +   
  geom_point()+    
  geom_smooth(method="lm")
```

**Calculate marginal means**

```{r}
library(emmeans) 
marginal_means<- emmeans(davies_lmer4, ~median_speed) 
marginal_means_df <- as.data.frame(marginal_means) 
head(marginal_means_df)
```

Calculate marginal means for the categorical variable

```{r}
marginal_means_cat <- emmeans(davies_lmer4cat, ~ median_speed_cat) 
marginal_means_cat_df <- as.data.frame(marginal_means_cat)  

# Inspect the marginal means dataframe 
head(marginal_means_cat_df) 
```

Calculate marginal means for log transformed response variable

```{r}
marginal_means_log<- emmeans(davies_lmer4, ~median_speed) 
marginal_means_log_df <- as.data.frame(marginal_means)  
head(marginal_means_df)
```

Vizualize marginal means with median speed as a continuous variable

```{r}
# Plot raw data with marginal means - RAW DATA SCALE 
ggplot() +   
  geom_point(data = davies, aes(x = median_speed, y = Size)) +   
  geom_line(data = marginal_means_df, 
            aes(x = median_speed, y = emmean, group = 1), 
            size = 1) +   
  geom_pointrange(data = marginal_means_df, 
                  aes(x = median_speed, y = emmean, ymin = lower.CL, ymax = upper.CL), 
                  size = 1, 
                  color = "blue") +   
  labs(title = "Raw Data and Marginal Means: Size vs. Median Speed - continuous ",        
       x = "Median Flow velocity (m/s)",        
       y = "Size") +   
  theme_modern()  

# Plot raw data with marginal means - LOG TRANSFORMED SCALE 
ggplot() +   
  geom_point(data = davies, 
             aes(x = median_speed, y = Size_log), 
             alpha = 0.3) +   
  geom_line(data = marginal_means_log_df, 
            aes(x = median_speed, y = emmean, group = 1), 
            size = 1) +   
  geom_pointrange(data = marginal_means_log_df, 
                  aes(x = median_speed, y = emmean, ymin = lower.CL, ymax = upper.CL), 
                  size = 1, 
                  color = "blue") +  
  labs(title = "Raw Data and Marginal Means: Log(Size) vs. Median Speed (Continuous)",        
       x = "Median Flow velocity (m/s)",       
       y = "log(Size)") +  
  theme_modern() 
```

And with median speed as a categorical variable

```{r}
# Plot raw data with marginal means and confidence intervals for categorical variable 
ggplot() +   
  geom_point(data = davies, aes(x = median_speed_cat, y = Size), alpha = 0.3) +  # Raw data points with transparency   
  geom_line(data = marginal_means_cat_df, aes(x = median_speed_cat, y = emmean, group = 1), color = "blue", size = 1) + 
  geom_errorbar(data = marginal_means_cat_df, aes(x = median_speed_cat, ymin = lower.CL, ymax = upper.CL), width = 0.2, color = "blue") +   
  theme_minimal() +   
  labs(title = "Raw Data and Marginal Means: Size vs. Median Speed (Categorical)",        
       x = "Median Speed (Categorical)",        
       y = "Size") +   
  theme_modern()
```

# Heron - models with [species]{.underline}

Make Site, ReefDev (id) AND Spp (**species**!) as factors

```{r}
heron$Site <- as.factor(heron$Site) 
heron$ReefDev<- as.factor(heron$ReefDev)
heron$Spp <- as.factor(heron$Spp) 
```

Make lmer models accounting for Species variability

```{r}
heronSpp1_lmer<- lmer(Size_log ~ (1|Site) + (1|ReefDev), data=heron)
#heronSpp2_lmer <- lmer(Size_log ~ (1|Site) + (Spp|ReefDev), data=heron)         #too complicated
heronSpp3_lmer <- lmer(Size_log ~ Spp + (1|Site) + (1|ReefDev), data=heron)
#heronSpp4_lmer <- lmer(Size_log ~ Spp + (1|Site) + (Spp|ReefDev), data=heron)   #too complicated
heronSpp5_lmer <- lmer(Size_log ~ Spp + (1|ReefDev), data=heron)
heronSpp6_lmer <- lmer(Size_log ~ Spp + (1|Site), data=heron)
#heronSpp7_lmer <- lmer(Size_log ~ Spp + (ReefDev|Site), data=heron)              #too complicated
heronSpp8_lmer <- lmer(Size_log ~ Spp + (1|Site/ReefDev), data=heron)

summary(heronSpp1_lmer)
summary(heronSpp3_lmer)
summary(heronSpp5_lmer)
summary(heronSpp6_lmer)

AIC(heronSpp1_lmer, heronSpp3_lmer,heronSpp5_lmer,heronSpp6_lmer,heronSpp8_lmer)
```

Conclusion: best model is lmer5, with spp as fixed effect and ReefDev as random effect. However, I want to assess variability between sites, thus will need to keep site in the model. Hence, moving forward will use the structure with **Spp as fixed effect and (1\|Site / ReefDev)** with Site as random effect and ReefDev nested within.

```{r}
heron_lmer1 <- lmer(Size_log ~ Spp + (1|Site/ReefDev), data=heron) 
heron_lmer2 <- lmer(Size_log ~ Ub_avrg + Spp + (1|Site/ReefDev), data=heron) 
heron_lmer3 <- lmer(Size_log ~ WaveEnergyLevel + Spp + (1|Site/ReefDev), data=heron)  
heron_lmer4 <- lmer(Size_log ~ median_speed + Spp + (1|Site/ReefDev), data=heron) 
heron_lmer5 <- lmer(Size_log ~ sedturf_t2 + sedconcrete_t2 + Spp + (1|Site/ReefDev), data=heron)  #singular issue
heron_lmer6 <- lmer(Size_log ~ sedturf_t2 +  Spp + (1|Site/ReefDev), data=heron)  #singular issue
heron_lmer7 <- lmer(Size_log ~ sedconcrete_t2 + Spp + (1|Site/ReefDev), data=heron)  #singular issue

#try for sediment data with only ReefDev as random effect, because of singular issue which may come from overfitting/too complext random effect structure
heron_lmer5a <- lmer(Size_log ~ sedturf_t2 + sedconcrete_t2 + Spp + (1|ReefDev), data=heron)
heron_lmer6a <- lmer(Size_log ~ sedturf_t2 +  Spp + (1|ReefDev), data=heron)
heron_lmer7a <- lmer(Size_log ~ sedconcrete_t2 + Spp +  (1|ReefDev), data=heron)

summary(heron_lmer1) 
summary(heron_lmer2) 
summary(heron_lmer3) 
summary(heron_lmer4) 
summary(heron_lmer5)
summary(heron_lmer6)
summary(heron_lmer7)

AIC(heron_lmer1, heron_lmer2, heron_lmer3, heron_lmer4, heron_lmer5, heron_lmer6, heron_lmer7)

AIC(heron_lmer5a, heron_lmer6a, heron_lmer7a)
```

Check models with Sedimentation as factor:

```{r}
#| warning: false
#| message: false
heron_long <- heron |>
  pivot_longer(cols = c(sedturf_t2, sedconcrete_t2), 
               names_to = "SedPod", 
               values_to = "Sedimentation")

heron_long$SedPod<- as.factor(heron_long$SedPod)

heron_lmer5a <- lmer(Size_log ~ sedturf_t2 + sedconcrete_t2 + Spp + (1|ReefDev), data=heron)

heron_lmer8 <- lmer(Size_log ~ SedPod * Sedimentation + Spp + (1|Site), data = heron_long)
heron_lmer9 <- lmer(Size_log ~ SedPod * Sedimentation + Spp + (1|ReefDev), data = heron_long)
heron_lmer10 <- lmer(Size_log ~ SedPod * Sedimentation + Spp + (1|Site/ReefDev), data = heron_long)

AIC(heron_lmer5a, heron_lmer8, heron_lmer9,heron_lmer10)
```

**Conclusion**: very poor performance of models if sedimentation is a factor. Moving forward with sedturf and sedconcrete as fixed effects in seperate models. Need to decide on keeping site in the model or only using ReefDev.

Vizualize lmer using Size as predictor

```{r}
#plot with raw data 
ggplot(data=heron, aes(y = Size_log, x = median_speed, color = Spp)) +    
  geom_point()+   
  geom_smooth(method="lm")  

#plot with raw data and poly smoothner 
ggplot(data=heron, aes(y = Size_log, x = median_speed, color = Spp)) +    
  geom_point()+    
  geom_smooth(method="lm", formula = y~poly(x,3), se = FALSE)  

```

Calculate marginal means

```{r}
library(emmeans) 
marginal_means<- emmeans(heron_lmer4, ~median_speed) 
marginal_means_df <- as.data.frame(marginal_means)  
head(marginal_means_df)
```

Vizualize marginal means with median speed as a continuous variable

```{r}
#|warning: false
#|mmessage: false
# Plot raw data with marginal means - RAW DATA SCALE 
ggplot() +   geom_point(data = heron, aes(x = median_speed, y = Size, color = Spp)) +  
  geom_line(data = marginal_means_df, aes(x = median_speed, y = emmean, group = 1), size = 1) +   
  geom_pointrange(data = marginal_means_df, aes(x = median_speed, y = emmean, ymin = lower.CL, ymax = upper.CL), size = 1, color = "blue") +  
  labs(title = "Raw Data and Marginal Means: Size vs. Median Speed - continuous ",        x = "Median Flow velocity (m/s)",        
       y = "Size") +   
  theme_modern()  

# Plot raw data with marginal means - LOG TRANSFORMED SCALE 
ggplot() +   
  geom_point(data = heron, 
             aes(x = median_speed, y = Size_log, color = Spp), 
             alpha = 0.3) +   
  geom_line(data = marginal_means_log_df, 
            aes(x = median_speed, y = emmean, group = 1), 
            size = 1) +  
  geom_pointrange(data = marginal_means_log_df, 
                  aes(x = median_speed, y = emmean, ymin = lower.CL, ymax = upper.CL), 
                  size = 1, 
                  color = "blue") +   
  labs(title = "Raw Data and Marginal Means: Log(Size) vs. Median Speed (Continuous)",        
       x = "Median Flow velocity (m/s)",        
       y = "log(Size)") +   
  theme_modern() 
```

# \-\-\-\-\-\-\-\-\-\-\-\-- Bayesian-----------------

# Moore

NOTE: I tried model structures with ReefDev nested within site (1\|Site/ReefDev), however it gives problems with the model stability and robustness (see poor pareto - k values when performing looic). Therefore continuing with model structure with only site as random effect in it, because it provides a more robust model, despite higher looic values.

**UPDATE** 24/08/2024 - Added **(1\|ReefDev)** as random factor to account for corals that are being counted on the same device

##### brm0 - null model

```{r}
moore_size_site <-  bf(Size_log ~ (1 | Site) + (1|ReefDev), family = gaussian())

priors <- prior(normal(0, 5), class = "Intercept") +  # for intercept
  prior(cauchy(0,2), class = 'sd') +                  # for random effects - Site
  prior(cauchy(0, 2), class = "sigma")                # for residual error (??)

moore_brm0_size <- brm(moore_size_site,
                 data=moore,
                 prior = priors,
                 sample_prior = 'yes',
                 iter = 5000,
                 warmup = 1000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.99),
                backend = "rstan")

# To save the model use >> 
#save(moore_brm0_size, file = "scripts/models/moore/size/moore_brm0_size.RData") 
```

##### brm1 - wave

```{r}
moore_size_wave <-  bf(Size_log ~ WaveEnergyLevel + (1 | Site) + (1|ReefDev), family = gaussian())

priors <- prior(normal(0, 5), class = "Intercept") +  # for intercept
  prior(normal(0,5), class = "b") +                   # for fixed effects - WaveEnergyLevel
  prior(cauchy(0,2), class = 'sd') +                  # for random effects - Site
  prior(cauchy(0, 2), class = "sigma")                # for residual error (??)

moore_brm1_size <- brm(moore_size_wave,
                 data=moore,
                 prior = priors,
                 sample_prior = 'yes',
                 iter = 5000,
                 warmup = 1000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.99),
                backend = "rstan")

# To save the model use >> 
#save(moore_brm1_size, file = "scripts/models/moore/size/moore_brm1_size.RData") 
```

Model diagnostics

```{r}
moore_brm1_size |> pp_check(type = 'dens_overlay', ndraws = 100)
moore_brm1_size |> pp_check (type = "error_scatter_avg")
moore_brm1_size  |> pp_check(group = 'Site', type = 'violin_grouped')

#moore.resids1 <- make_brms_dharma_res(moore_brm1_size, integerResponse = FALSE)
#testUniformity(moore.resids1)
#plotResiduals(moore.resids1)
#testDispersion(moore.resids1)
```

##### brm2 - Ub_avrg

```{r}
moore_size_Ub <-  bf(Size_log ~ Ub_avrg + (1 | Site) + (1|ReefDev), family = gaussian())

priors <- prior(normal(0, 5), class = "Intercept") +  # for intercept
  prior(normal(0,5), class = "b") +                   # for fixed effects - Ub
  prior(cauchy(0,2), class = 'sd') +                  # for random effects - Site
  prior(cauchy(0, 2), class = "sigma")                # for residual error (??)

moore_brm2_size <- brm(moore_size_Ub,
                 data=moore,
                 prior = priors,
                 sample_prior = 'yes',
                 iter = 5000,
                 warmup = 1000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.99),
                backend = "rstan")

# To save the model use >> 
#save(moore_brm2_size, file = "scripts/models/moore/size/moore_brm2_size.RData")
```

Model diagnostics

```{r}
moore_brm2_size |> pp_check(type = 'dens_overlay', ndraws = 100)
moore_brm2_size |> pp_check (type = "error_scatter_avg")
moore_brm2_size  |> pp_check(group = 'Site', type = 'violin_grouped')

#moore.resids2 <- make_brms_dharma_res(moore_brm2_size, integerResponse = FALSE)
#testUniformity(moore.resids2)
#plotResiduals(moore.resids2)
#testDispersion(moore.resids2)
```

##### brm3 - median_speed

```{r}
moore_size_speed <-  bf(Size_log ~ median_speed + (1|Site) + (1|ReefDev), family = gaussian())

priors <- prior(normal(0, 5), class = "Intercept") +  # for intercept
  prior(normal(0, 5), class = "b") +                 # for fixed effects - median_speed
  prior(cauchy(0, 2), class = 'sd') +                # for random effects - Site and ReefDev
  prior(cauchy(0, 2), class = "sigma")               # for residual error (??)

moore_brm3_size <- brm(moore_size_speed,
                 data=moore,
                 prior = priors,
                 sample_prior = 'yes',
                 iter = 5000,
                 warmup = 1000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.99),
                backend = "rstan")

# To save the model use >> 
#save(moore_brm3_size, file = "scripts/models/moore/size/moore_brm3_size.RData")

```

Model diagnostics

```{r}
moore_brm3_size |> pp_check(type = 'dens_overlay', ndraws = 100)
moore_brm3_size |> pp_check (type = "error_scatter_avg")
moore_brm3_size  |> pp_check(group = 'Site', type = 'violin_grouped')

#moore.resids3 <- make_brms_dharma_res(moore_brm3_size, integerResponse = FALSE)
#testUniformity(moore.resids3)
#plotResiduals(moore.resids3)
#testDispersion(moore.resids3)
```

##### brm4- sedturf_t5

```{r}
moore_size_sedturf <-  bf(Size_log ~ sedturf_t5 + (1|Site) + (1|ReefDev), family = gaussian())

priors <- prior(normal(0, 5), class = "Intercept") +  # for intercept
  prior(normal(0,5), class = "b") +                   # for fixed effects - speed
  prior(cauchy(0,2), class = 'sd') +                  # for random effects - Site
  prior(cauchy(0, 2), class = "sigma")                # for residual error (??)

moore_brm4_size <- brm(moore_size_sedturf,
                 data=moore,
                 prior = priors,
                 sample_prior = 'yes',
                 iter = 5000,
                 warmup = 1000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.99),
                backend = "rstan")

# To save the model use >> 
#save(moore_brm4_size, file = "scripts/models/moore/size/moore_brm4_size.RData")
```

Model diagnostics:

```{r}
moore_brm4_size |> pp_check(type = 'dens_overlay', ndraws = 100)
moore_brm4_size |> pp_check (type = "error_scatter_avg")
moore_brm4_size  |> pp_check(group = 'Site', type = 'violin_grouped')

#moore.resids4 <- make_brms_dharma_res(moore_brm4_size, integerResponse = FALSE)
#testUniformity(moore.resids4)
#plotResiduals(moore.resids4)
#testDispersion(moore.resids4)
```

##### brm5 - sedconcrete_t5

```{r}
moore_size_concrete <-  bf(Size_log ~ sedconcrete_t5 + (1|Site) + (1|ReefDev), family = gaussian())  

priors <- prior(normal(0, 5), class = "Intercept") +  # for intercept   
  prior (normal(0,5), class = "b") +                 # for fixed effects - concrete
  prior(cauchy(0,2), class = 'sd') +                    # for random effects - Site 
  prior(cauchy(0, 2), class = "sigma")               # for residual error (??)

moore_brm5_size <- brm(moore_size_concrete,         
                       data=moore,          
                       prior = priors,      
                       sample_prior = 'yes',  
                       iter = 5000,             
                       warmup = 1000,           
                       chains = 3, 
                       cores = 3,             
                       thin = 5,         
                       refresh = 0,   
                       control = list(adapt_delta = 0.99),  
                       backend = "rstan") 

# To save the model use >>  
#save(moore_brm5_size, file = "scripts/models/moore/size/moore_brm5_size.RData")
```

Model diagnostics

```{r}
moore_brm5_size |> pp_check(type = 'dens_overlay', ndraws = 100) 
moore_brm5_size |> pp_check (type = "error_scatter_avg") 
moore_brm5_size  |> pp_check(group = 'Site', type = 'violin_grouped')  

#moore.resids5 <- make_brms_dharma_res(moore_brm5_size, integerResponse = FALSE) 
#testUniformity(moore.resids5) 
#plotResiduals(moore.resids5) 
#testDispersion(moore.resids5)
```

##### brm6 - habitat

```{r}
moore_size_habitat <-  bf(Size_log ~ PC1 + PC2 + (1|Site) + (1|ReefDev), family = gaussian())

priors <- prior(normal(0, 5), class = "Intercept") +  # for intercept
  prior(normal(0,5), class = "b") +                   # for fixed effects - speed
  prior(cauchy(0,2), class = 'sd') +                    # for random effects - Site
  prior(cauchy(0, 2), class = "sigma")               # for residual error (??)

moore_brm6_size <- brm(moore_size_habitat,
                 data=moore,
                 prior = priors,
                 sample_prior = 'yes',
                 iter = 5000,
                 warmup = 1000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.99),
                backend = "rstan")

# To save the model use >> 
#save(moore_brm6_size, file = "scripts/models/moore/size/moore_brm6_size.RData")
```

Model diagnostics

```{r}
moore_brm6_size |> pp_check(type = 'dens_overlay', ndraws = 100)
moore_brm6_size |> pp_check (type = "error_scatter_avg")
moore_brm6_size  |> pp_check(group = 'Site', type = 'violin_grouped')

#moore.resids6 <- make_brms_dharma_res(moore_brm6_size, integerResponse = FALSE)
#testUniformity(moore.resids6)
#plotResiduals(moore.resids6)
#testDispersion(moore.resids6)
```

INTERPRETATION:

**dens-overlay:** dark blue line represent the density of the observed data, the light blue lines represent the densities of simulated data from the posterior predictive distribution of the model (thus "replicated data"). Reasonable fit, the peak is around zero for the observed and replicated data, also the observed density falls generally within the rand of the replicated densities, suggesting that the model is performing well in capturing the overall distribution of the observed data.

**error-scatter:** x-acis shows the average difference between the observed data and replicated (simulated) data. The y-axis represents the observed data. An ideal fit would be when the points cluster around the diagonal line where y is equal to the average yrep. In this case, the scatter points show a positive trend, indicating that higher observed values (y) correspond to higher average differences (y - yrep). The points are reasonably well aligned with the diagonal line, suggesting that the model's predictions are generally consistent with the observed data. However, there are some deviations at the higher observed values, suggesting that the model might not be fully capturing the variability in these observations.

**violin-plot:** the black line represent the distribution of the observed data within each site. They light blue fill represents the distribution of the simulated data within each site. Wider sections indicate higher density. A good fit would be when the black outlines are well alligned with the light blue fill, indicating that the model's simulated data closely matches the observed data. In this case, the observed data at most sites are well aligned with the predicted data, suggesting that the model captures the general distribution within these sites. However, some sites have a little deviation, for instance site M4A has a wider spread in the observed data compared to the simulated data.

**QQ-residuals:** the red line represents the expected theoretical quantiles if the residuals were perfectly uniform. However, the observed quantiles deviate from the red line, which is consistent with the Kolmogorov-Smirnov test (p-value = 0.02334), indicating significant deviation from uniformity.

**Residuals vs. Predicted**: The black points should ideally scatter around the horizontal line at 0.5 if the model fits well. The black line (trend) should be flat if there are no systematic deviations. The plot shows some deviations from the horizontal line, suggesting possible non-uniformity or other issues. The red curve indicates the detected quantile deviations, suggesting some systematic deviations in certain quantiles of the residuals. However, the combined adjusted quantile test is not significant, suggesting that while there are some deviations, they are not strong enough to be statistically significant.

**Dispersion test:** Evaluates whether the residual variance (dispersion) in the model is consistent with the expected variance under the model's assumptions. The histogram shows the distribution of the simulated residual standard deviations. The red line (fitted model) lies well within the bulk of the simulated values, suggesting that the model does not exhibit significant dispersion issues. Also, the output shows a dispersion of 0.87029. A dispersion parameter close to 1 indicates that the observed residual variance is consistent with the model's expectations. In this case, the dispersion parameter is 0.87029, which is close to 1. Also, the p-value is 0.69, suggesting that there is no significant overdispersion or underdispersion.

### Load models

```{r}
load(file = "scripts/models/moore/size/moore_brm0_size.RData")
load(file = "scripts/models/moore/size/moore_brm1_size.RData")
load(file = "scripts/models/moore/size/moore_brm2_size.RData")
load(file = "scripts/models/moore/size/moore_brm3_size.RData")
load(file = "scripts/models/moore/size/moore_brm4_size.RData")
load(file = "scripts/models/moore/size/moore_brm5_size.RData")
load(file = "scripts/models/moore/size/moore_brm6_size.RData")

#OR models with (1|Site/ReefDev) as random effect
load(file = "scripts/models/moore/size/moore_brm1_nested.RData")
load(file = "scripts/models/moore/size/moore_brm2_nested.RData") 

#OR models with (1|ReefDev) as random effect
load(file = "scripts/models/moore/size/moore_brm1_reefdev.RData")
```

### Loo compare

```{r}
#Using loo compare, lower value is better
l_wave <- moore_brm1_size |> loo()
l_Ub <- moore_brm2_size |> loo()
l_speed <- moore_brm3_size |> loo()
l_turf <- moore_brm4_size|> loo()
l_concrete <- moore_brm5_size|> loo()
l_habitat <- moore_brm6_size|> loo()

looic(moore_brm1_size)       #  LOOIC: 319.81 [15.50]
looic(moore_brm2_size)       #  LOOIC: 318.10 [15.52]
looic(moore_brm3_size)       #  LOOIC: 319.76 [15.47]
looic(moore_brm4_size)       #  LOOIC: 320.39 [15.53]
looic(moore_brm5_size)       #  LOOIC: 318.99 [15.31]
looic(moore_brm6_size)       #  LOOIC: 303.06 [16.54]

l_speed
l_Ub
l_wave
l_turf
l_concrete
l_habitat
```

**NOTES ON THIS:**

**LOOIC (Leave-One-Out Information Criterion)**: A measure of the model's predictive accuracy. Lower LOOIC values indicate a better model.

**ELPD (Expected Log Predictive Density)**: A measure of the model's predictive performance. Higher ELPD values indicate a better model.

**Standard Error (SE)**: The standard error of the LOOIC or ELPD estimates.

**\*\* Best Model**: `moore_brm6_size` ([l_habitat]{.underline}) has the highest ELPD(-151.53) and the lowest LOOIC (303.06), indicating the best predictive performance among the models compared.

**\*\* Worst Model**: `moore_brm4_size` ([l_turf]{.underline}) has the lowest ELPD and the highest LOOIC, indicating the worst predictive performance among the models compared.

### Summary

```{r}
summary(moore_brm0_size)
summary(moore_brm1_size)
summary(moore_brm2_size)
summary(moore_brm3_size)
summary(moore_brm4_size)
summary(moore_brm5_size)
summary(moore_brm6_size)
```

**NOTES ON THIS:** None of the predictors (PC1, PC2, WaveEnergyLevel, Ub_avrg, median_speed, sedturf_t5, sedconcrete_t5) have credible intervals that exclude zero, suggesting that these predictors are not significantly associated with `Size_log`. According to the LOOIC and ELPD values above, moore_brm6_size (with PC1 and PC2) seems to be the best model.

All models have good convergence diagnostics (Rhat = 1.00) and sufficient effect sample sizes (Bulk_ESS and Tail_ESS) indicating reliable parameter estimates.

### Pairwise comparisons

```{r}
# Fit your model
moore_brm <- brm(Size ~ Site + (1|ReefDev), data = moore, family = gaussian())

# Define hypotheses for pairwise comparisons
hypotheses <- c(
  "SiteM1B - SiteM4A = 0",
  "SiteM2A - SiteM4A = 0",
  "SiteM2B - SiteM4A = 0",
  "SiteM3A - SiteM4A = 0",
  "SiteM3B - SiteM4A = 0",
  "SiteM4B - SiteM4A = 0",
  "SiteM5A - SiteM4A = 0",
  "SiteM5B - SiteM4A = 0"
)

# Test the hypotheses
hypothesis_results <- hypothesis(moore_brm, hypotheses)

# Print the results
print(hypothesis_results)

hypothesis_results_summary <- hypothesis_results$hypothesis
hypothesis_results_summary 

```

# \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

# Davies

NOTE: Same as with Moore models, I tried model structures with ReefDev nested within site (1\|Site/ReefDev), however it gives problems with the model stability and robustness (see poor pareto - k values when performing looic). Therefore continuing with model structure with only site as random effect in it, because it provides a more robust model, despite higher looic values.

UPDATE 24/08/2024 - Added (1\|ReefDev) to account for corals being counted on the same device

##### brm0 - site

```{r}
davies_size_site <-  bf(Size_log ~ (1|Site) + (1|ReefDev), family = gaussian())  

priors <- prior(normal(0, 5), class = "Intercept") +  # for intercept   
  prior(cauchy(0,2), class = 'sd') +                   # for random effects - Site 
  prior(cauchy(0, 2), class = "sigma")               # for residual error (??)

davies_brm0_size <- brm(davies_size_site,                  
                       data=davies,                  
                       prior = priors,                  
                       sample_prior = 'yes',                  
                       iter = 5000,                  
                       warmup = 1000,                  
                       chains = 3, cores = 3,                  
                       thin = 5,                  
                       refresh = 0,                  
                       control = list(adapt_delta = 0.99),                 
                       backend = "rstan")  

# To save the model use >>  
#save(davies_brm0_size, file = "scripts/models/davies/size/davies_brm0_size.RData")
```

##### brm1 - wave

```{r}
davies_size_wave <-  bf(Size_log ~ WaveEnergyLevel + (1|Site) + (1|ReefDev), family = gaussian())  

priors <- prior(normal(0, 5), class = "Intercept") +  # for intercept   
  prior(normal(0,5), class = "b") +                   # for fixed effects - WaveEnergyLevel   
  prior(cauchy(0,2), class = 'sd') +                   # for random effects - Site 
  prior(cauchy(0, 2), class = "sigma")               # for residual error (??)

davies_brm1_size <- brm(davies_size_wave,                  
                       data=davies,                  
                       prior = priors,                  
                       sample_prior = 'yes',                  
                       iter = 5000,                  
                       warmup = 1000,                  
                       chains = 3, cores = 3,                  
                       thin = 5,                  
                       refresh = 0,                  
                       control = list(adapt_delta = 0.99),                 
                       backend = "rstan")  

# To save the model use >>  
#save(davies_brm1_size, file = "scripts/models/davies/size/davies_brm1_size.RData")
```

Model diagnostics

```{r}
davies_brm1_size |> pp_check(type = 'dens_overlay', ndraws = 100) 
davies_brm1_size |> pp_check (type = "error_scatter_avg") 
davies_brm1_size  |> pp_check(group = 'Site', type = 'violin_grouped') 

#davies.resids1 <- make_brms_dharma_res(davies_brm1_size, integerResponse = FALSE) 
#testUniformity(davies.resids1) 
#plotResiduals(davies.resids1) 
#testDispersion(davies.resids1)
```

##### brm2 - Ub_avrg

```{r}
davies_size_Ub <-  bf(Size_log ~ Ub_avrg + (1|Site)+ (1|ReefDev), family = gaussian())  
priors <- prior(normal(0, 5), class = "Intercept") +  # for intercept   
  prior(normal(0,5), class = "b") +                   # for fixed effects - Ub   
  prior(cauchy(0,2), class = 'sd') +                    # for random effects - Site  
  prior(cauchy(0, 2), class = "sigma")               # for residual error (??)

davies_brm2_size <- brm(davies_size_Ub,                  
                       data=davies,                  
                       prior = priors,                  
                       sample_prior = 'yes',               
                       iter = 5000,                  
                       warmup = 1000,                
                       chains = 3, 
                       cores = 3,     
                       thin = 5,   
                       refresh = 0,              
                       control = list(adapt_delta = 0.99),  
                       backend = "rstan")  

# To save the model use >>  
#save(davies_brm2_size, file = "scripts/models/davies/size/davies_brm2_size.RData")
```

Model diagnostics

```{r}
davies_brm2_size |> pp_check(type = 'dens_overlay', ndraws = 100) 
davies_brm2_size |> pp_check (type = "error_scatter_avg") 
davies_brm2_size  |> pp_check(group = 'Site', type = 'violin_grouped')  

#davies.resids2 <- make_brms_dharma_res(davies_brm2_size, integerResponse = FALSE) 
#testUniformity(davies.resids2) 
#plotResiduals(davies.resids2) 
#testDispersion(davies.resids2)
```

##### brm3 - median_speed

```{r}
davies_size_speed <-  bf(Size_log ~ median_speed + (1|Site)+ (1|ReefDev), family = gaussian())  
priors <- prior(normal(0, 5), class = "Intercept") +  # for intercept   
  prior(normal(0,5), class = "b") +                   # for fixed effects - speed   
  prior(cauchy(0,2), class = 'sd') +                   # for random effects - Site 
  prior(cauchy(0, 2), class = "sigma")               # for residual error (??)

davies_brm3_size <- brm(davies_size_speed,               
                       data=davies,              
                       prior = priors,    
                       sample_prior = 'yes',           
                       iter = 5000,     
                       warmup = 1000,         
                       chains = 3, 
                       cores = 3,       
                       thin = 5,                 
                       refresh = 0,          
                       control = list(adapt_delta = 0.99),     
                       backend = "rstan")  

# To save the model use >>  
#save(davies_brm3_size, file = "scripts/models/davies/size/davies_brm3_size.RData") 
```

Model diagnostics

```{r}
davies_brm3_size |> pp_check(type = 'dens_overlay', ndraws = 100)
davies_brm3_size |> pp_check (type = "error_scatter_avg")
davies_brm3_size  |> pp_check(group = 'Site', type = 'violin_grouped') 

#davies.resids3 <- make_brms_dharma_res(davies_brm3_size, integerResponse = FALSE)
#testUniformity(davies.resids3) 
#plotResiduals(davies.resids3) 
#testDispersion(davies.resids3)
```

##### brm4- sedturf

```{r}
davies_size_turf <-  bf(Size_log ~ sedturf + (1|Site)+ (1|ReefDev), family = gaussian()) 

priors <- prior(normal(0, 5), class = "Intercept") +  # for intercept  
  prior(normal(0,5), class = "b") +                   # for fixed effects - speed 
  prior(cauchy(0,2), class = 'sd') +                    # for random effects - Site
  prior(cauchy(0, 2), class = "sigma")               # for residual error (??)

davies_brm4_size <- brm(davies_size_turf,                
                       data=davies,           
                       prior = priors,             
                       sample_prior = 'yes',             
                       iter = 5000,         
                       warmup = 1000,    
                       chains = 3, 
                       cores = 3,    
                       thin = 5,             
                       refresh = 0,                 
                       control = list(adapt_delta = 0.99),      
                       backend = "rstan") 

# To save the model use >>  
#save(davies_brm4_size, file = "scripts/models/davies/size/davies_brm4_size.RData") 
```

Model diagnostics

```{r}
davies_brm4_size |> pp_check(type = 'dens_overlay', ndraws = 100) 
davies_brm4_size |> pp_check (type = "error_scatter_avg") 
davies_brm4_size  |> pp_check(group = 'Site', type = 'violin_grouped') 

#davies.resids4 <- make_brms_dharma_res(davies_brm4_size, integerResponse = FALSE) 
#testUniformity(davies.resids4) 
#plotResiduals(davies.resids4) 
#testDispersion(davies.resids4)
```

##### brm5 - sedconcrete

```{r}
davies_size_concrete <-  bf(Size_log ~ sedconcrete + (1|Site)+ (1|ReefDev), family = gaussian()) 
priors <- prior(normal(0, 5), class = "Intercept") +  # for intercept  
  prior(normal(0,5), class = "b") +                   # for fixed effects - speed   
  prior(cauchy(0,2), class = 'sd') +                   # for random effects - Site
  prior(cauchy(0, 2), class = "sigma")               # for residual error (??)

davies_brm5_size <- brm(davies_size_concrete,            
                       data=davies,              
                       prior = priors,               
                       sample_prior = 'yes',              
                       iter = 5000,            
                       warmup = 1000,     
                       chains = 3, 
                       cores = 3,       
                       thin = 5,            
                       refresh = 0,               
                       control = list(adapt_delta = 0.99), 
                       backend = "rstan")  

# To save the model use >>  
#save(davies_brm5_size, file = "scripts/models/davies/size/davies_brm5_size.RData")
```

Model diagnostics

```{r}
davies_brm5_size |> pp_check(type = 'dens_overlay', ndraws = 100) 
davies_brm5_size |> pp_check (type = "error_scatter_avg") 
davies_brm5_size  |> pp_check(group = 'Site', type = 'violin_grouped') 

#davies.resids5 <- make_brms_dharma_res(davies_brm5_size, integerResponse = FALSE) 
#testUniformity(davies.resids5) 
#plotResiduals(davies.resids5)
#testDispersion(davies.resids5)
```

##### brm8 - habitat

```{r}
davies_size_habitat <-  bf(Size_log ~ PC1 + PC2 + (1|Site)+ (1|ReefDev), family = gaussian())  

priors <- 
  prior(normal(0, 5), class = "Intercept") +  # for the intercept   
  prior(normal(0, 5), class = "b") +  # for fixed effects - PC1, PC2, Spp, and interactions
  prior(cauchy(0, 2), class = 'sd') +  # for random effects - Site and ReefDev
  prior(cauchy(0, 2), class = "sigma")  # for residual error (??)


davies_brm8_size <- brm(davies_size_habitat, 
                       data=davies,             
                       prior = priors,  
                       sample_prior = 'yes',        
                       iter = 5000,            
                       warmup = 1000,          
                       chains = 3, 
                       cores = 3,  
                       thin = 5,           
                       refresh = 0,         
                       control = list(adapt_delta = 0.99),      
                       backend = "rstan")  

# To save the model use >> 
#save(davies_brm8_size, file = "scripts/models/davies/size/davies_brm8_size.RData")
```

Model diagnostics

```{r}
davies_brm8_size |> pp_check(type = 'dens_overlay', ndraws = 100)
davies_brm8_size |> pp_check (type = "error_scatter_avg") 
davies_brm8_size  |> pp_check(group = 'Site', type = 'violin_grouped') 

#davies.resids8 <- make_brms_dharma_res(davies_brm8_size, integerResponse = FALSE) 
#testUniformity(davies.resids8) 
#plotResiduals(davies.resids8)
#testDispersion(davies.resids8)
```

INTERPRETATION:

**dens-overlay:** dark blue line represent the density of the observed data, the light blue lines represent the densities of simulated data from the posterior predictive distribution of the model (thus "replicated data"). Reasonable fit, the peak is around zero for the observed and replicated data, also the observed density falls generally within the rand of the replicated densities, suggesting that the model is performing well in capturing the overall distribution of the observed data.

**error-scatter:** x-acis shows the average difference between the observed data and replicated (simulated) data. The y-axis represents the observed data. An ideal fit would be when the points cluster around the diagonal line where y is equal to the average yrep. In this case, the scatter points show a positive trend, indicating that higher observed values (y) correspond to higher average differences (y - yrep). The points are reasonably well aligned with the diagonal line, suggesting that the model's predictions are generally consistent with the observed data. However, there are some deviations at the higher observed values, suggesting that the model might not be fully capturing the variability in these observations.

**violin-plot:** the black line represent the distribution of the observed data within each site. They light blue fill represents the distribution of the simulated data within each site. Wider sections indicate higher density. A good fit would be when the black outlines are well alligned with the light blue fill, indicating that the model's simulated data closely matches the observed data. In this case, the observed data at most sites are well aligned with the predicted data, suggesting that the model captures the general distribution within these sites. However, some sites have a little deviation, for instance site M4A has a wider spread in the observed data compared to the simulated data.

**QQ-residuals:** the red line represents the expected theoretical quantiles if the residuals were perfectly uniform. However, the observed quantiles deviate from the red line, which is consistent with the Kolmogorov-Smirnov test, indicating significant deviation from uniformity.

**Residuals vs. Predicted**: The black points should ideally scatter around the horizontal line at 0.5 if the model fits well. The black line (trend) should be flat if there are no systematic deviations. The plot shows some deviations from the horizontal line, suggesting possible non-uniformity or other issues. The red curve indicates the detected quantile deviations, suggesting some systematic deviations in certain quantiles of the residuals. However, the combined adjusted quantile test is not significant, suggesting that while there are some deviations, they are not strong enough to be statistically significant.

**Dispersion test:** Evaluates whether the residual variance (dispersion) in the model is consistent with the expected variance under the model's assumptions. The histogram shows the distribution of the simulated residual standard deviations. The red line (fitted model) lies well within the bulk of the simulated values, suggesting that the model does not exhibit significant dispersion issues. Also, the output shows a dispersion of 0.87029. A dispersion parameter close to 1 indicates that the observed residual variance is consistent with the model's expectations. In this case, the dispersion parameter is 0.87029, which is close to 1. Also, the p-value is 0.69, suggesting that there is no significant overdispersion or underdispersion.

#### Load models

```{r}
load(file = "scripts/models/davies/size/davies_brm1_size.RData") 
load(file = "scripts/models/davies/size/davies_brm2_size.RData")
load(file = "scripts/models/davies/size/davies_brm3_size.RData")
load(file = "scripts/models/davies/size/davies_brm4_size.RData") 
load(file = "scripts/models/davies/size/davies_brm5_size.RData")
load(file = "scripts/models/davies/size/davies_brm8_size.RData")

#OR models with (1|Site/ReefDev) as random effect
#load(file = "scripts/models/davies/size/davies_brm1_nested.RData")
```

#### Loo compare

```{r}
#Using loo compare, lower value is better 
l_wave <- davies_brm1_size |> loo() 
l_Ub <- davies_brm2_size |> loo() 
l_speed <- davies_brm3_size |> loo() 
l_turf <- davies_brm4_size|> loo() 
l_concrete <- davies_brm5_size|> loo()
l_habitat <- davies_brm8_size|> loo() 

looic(davies_brm0_size)          #  LOOIC: 131.66 [11.21]
looic(davies_brm1_size)          #  LOOIC: 132.65 [10.79]
looic(davies_brm2_size)          #  LOOIC: 132.85 [11.06]
looic(davies_brm3_size)          #  LOOIC: 133.06 [11.11]
looic(davies_brm4_size)          #  LOOIC: 132.60 [11.74]
looic(davies_brm5_size)          #  LOOIC: 131.95 [11.08]
looic(davies_brm8_size)          #  LOOIC: 134.29 [10.67]


l_speed 
l_Ub
l_wave
l_turf
l_concrete
l_habitat
```

**NOTES ON THIS:**

**LOOIC (Leave-One-Out Information Criterion)**: A measure of the model's predictive accuracy. Lower LOOIC values indicate a better model.

**ELPD (Expected Log Predictive Density)**: A measure of the model's predictive performance. Higher ELPD values indicate a better model.

**Standard Error (SE)**: The standard error of the LOOIC or ELPD estimates.

**\*\* Best Model**: `davies_brm5_size` ([l_concrete_t2]{.underline}) has the highest ELPD(-65.86) and the lowest LOOIC (131.72), indicating the best predictive performance among the models compared. However, davies_brm4_size (l_turf_t2) is in a close second place.

#### Summary

```{r}
summary(davies_brm0_size)
summary(davies_brm1_size)
summary(davies_brm2_size)
summary(davies_brm3_size)
summary(davies_brm4_size)
summary(davies_brm5_size)
summary(davies_brm8_size)
```

**NOTES ON THIS:**

-   **Random Effects**: The standard deviation for the intercepts across all models suggests some variability among the sites.

-   **Fixed Effects**: None of the predictors (WaveEnergyLevel, Ub_avrg, median_speed, sedturf_t2, sedconcrete_t2, sedturf_t5) are statistically significant in predicting `Size_log`.

-   **Residuals**: The residual standard deviation (sigma) is consistent across models, indicating a similar level of unexplained variance.

Based on the LOOIC and ELPD values, **davies_brm5_size** appears to be the best-fitting model among those evaluated. However, since none of the fixed effects are significant, it suggests that these predictors may not be strong influencers of `Size_log` in this dataset.

All models have good convergence diagnostics (Rhat = 1.00) and sufficient effect sample sizes (Bulk_ESS and Tail_ESS) indicating reliable parameter estimates.

# \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

# Heron

NOTE: Same as with Moore and Davies models, I tried model structures with ReefDev nested within site (1\|Site/ReefDev), however it gives problems with the model stability and robustness (see poor pareto - k values when performing looic). And also some divergent transactions after warm-up. Therefore continuing with model structure with only site as random effect in it, because it provides a more robust model, despite higher looic values.

##### brm0 - site

```{r}
heron_size <-  bf(Size_log ~ (1|Site)+ (1|ReefDev) + Spp, family = gaussian())

priors <- prior(normal(0, 5), class = "Intercept") +  # for intercept   
  prior(normal(0,5), class = "b") +                   # for fixed effects - WaveEnergyLevel   
  prior(cauchy(0,2), class = 'sd')  +                  # for random effects - Site 
  prior(cauchy(0, 2), class = "sigma")  # for residual error (??)

heron_brm0_size_Spp <- brm(heron_size,                  
                       data=heron,                  
                       prior = priors,                 
                       sample_prior = 'yes',          
                       iter = 5000,               
                       warmup = 1000,             
                       chains = 3, 
                       cores = 3,        
                       thin = 5,            
                       refresh = 0,            
                       control = list(adapt_delta = 0.99),   
                       backend = "rstan")  

# To save the model use >>  
#save(heron_brm0_size_Spp, file = "scripts/models/heron/size/heron_brm0_size_Spp.RData")
```

Model diagnostics

```{r}
heron_brm0_size_Spp |> pp_check(type = 'dens_overlay', ndraws = 100) 
heron_brm0_size_Spp |> pp_check (type = "error_scatter_avg") 
heron_brm0_size_Spp  |> pp_check(group = 'Site', type = 'violin_grouped') 

#heron.resids0 <- make_brms_dharma_res(heron_brm0_size_Spp, integerResponse = FALSE)
#testUniformity(heron.resids0) 
#plotResiduals(heron.resids0)
#testDispersion(heron.resids0)
```

##### brm1 - wave

```{r}
heron_size_wave <-  bf(Size_log ~ WaveEnergyLevel * Spp + (1|Site) + (1|ReefDev), family = gaussian())

priors <- prior(normal(0, 5), class = "Intercept") +  # for intercept   
  prior(normal(0,5), class = "b") +                   # for fixed effects - WaveEnergyLevel   
  prior(cauchy(0,2), class = 'sd') +                   # for random effects - Site  
  prior(cauchy(0, 2), class = "sigma")  # for residual error (??)

heron_brm1_size_Spp <- brm(heron_size_wave,                  
                       data=heron,                  
                       prior = priors,                 
                       sample_prior = 'yes',          
                       iter = 5000,               
                       warmup = 1000,             
                       chains = 3, 
                       cores = 3,        
                       thin = 5,            
                       refresh = 0,            
                       control = list(adapt_delta = 0.99),   
                       backend = "rstan")  

# To save the model use >>  
#save(heron_brm1_size_Spp, file = "scripts/models/heron/size/heron_brm1_size_Spp.RData")
```

Model diagnostics

```{r}
heron_brm1_size_Spp |> pp_check(type = 'dens_overlay', ndraws = 100) 
heron_brm1_size_Spp |> pp_check (type = "error_scatter_avg") 
heron_brm1_size_Spp  |> pp_check(group = 'Site', type = 'violin_grouped') 

#heron.resids1 <- make_brms_dharma_res(heron_brm1_size_Spp, integerResponse = FALSE)
#testUniformity(heron.resids1) 
#plotResiduals(heron.resids1)
#testDispersion(heron.resids1)
```

##### brm2 - Ub_avrg

```{r}
heron_size_Ub <-  bf(Size_log ~ Ub_avrg * Spp + (1|Site) + (1|ReefDev), family = gaussian())  

priors <- prior(normal(0, 5), class = "Intercept") +  # for intercept   
  prior(normal(0,5), class = "b") +                   # for fixed effects - Ub  
  prior(cauchy(0,2), class = 'sd')  +                  # for random effects - Site 
  prior(cauchy(0, 2), class = "sigma")  # for residual error (??)

heron_brm2_size_Spp <- brm(heron_size_Ub,                 
                       data=heron,          
                       prior = priors,               
                       sample_prior = 'yes',           
                       iter = 5000,         
                       warmup = 1000,     
                       chains = 3, 
                       cores = 3,   
                       thin = 5,    
                       refresh = 0,            
                       control = list(adapt_delta = 0.99),   
                       backend = "rstan")  

# To save the model use >>  
#save(heron_brm2_size_Spp, file = "scripts/models/heron/size/heron_brm2_size_Spp.RData")
```

Model diagnostics

```{r}
heron_brm2_size_Spp |> pp_check(type = 'dens_overlay', ndraws = 100) 
heron_brm2_size_Spp |> pp_check (type = "error_scatter_avg") 
heron_brm2_size_Spp  |> pp_check(group = 'Site', type = 'violin_grouped') 

#heron.resids2 <- make_brms_dharma_res(heron_brm2_size_Spp, integerResponse = FALSE)
#testUniformity(heron.resids2) 
#plotResiduals(heron.resids2)
#testDispersion(heron.resids2)
```

##### brm3 - median_speed

```{r}
heron_size_speed <-  bf(Size_log ~ median_speed * Spp + (1|Site) + (1|ReefDev), family = gaussian())  

priors <- prior(normal(0, 5), class = "Intercept") +  # for intercept   
  prior(normal(0,5), class = "b") +                   # for fixed effects - Speed 
  prior(cauchy(0,2), class = 'sd')  +                  # for random effects - Site  
  prior(cauchy(0, 2), class = "sigma")  # for residual error (??)

heron_brm3_size_Spp <- brm(heron_size_speed,                 
                       data=heron,          
                       prior = priors,               
                       sample_prior = 'yes',           
                       iter = 5000,         
                       warmup = 1000,     
                       chains = 3, 
                       cores = 3,   
                       thin = 5,    
                       refresh = 0,            
                       control = list(adapt_delta = 0.99),   
                       backend = "rstan")  

# To save the model use >>  
#save(heron_brm3_size_Spp, file = "scripts/models/heron/size/heron_brm3_size_Spp.RData") 
```

Model diagnostics

```{r}
heron_brm3_size_Spp |> pp_check(type = 'dens_overlay', ndraws = 100) 
heron_brm3_size_Spp |> pp_check (type = "error_scatter_avg") 
heron_brm3_size_Spp  |> pp_check(group = 'Site', type = 'violin_grouped') 

#heron.resids3 <- make_brms_dharma_res(heron_brm3_size_Spp, integerResponse = FALSE)
#testUniformity(heron.resids3) 
#plotResiduals(heron.resids3)
#testDispersion(heron.resids3)
```

##### brm4- sedturf_t2

```{r}
heron_size_turf <-  bf(Size_log ~ sedturf_t2 * Spp + (1|Site) + (1|ReefDev), family = gaussian())  

priors <- prior(normal(0, 5), class = "Intercept") +  # for intercept   
  prior(normal(0,5), class = "b") +                   # for fixed effects - sedturf 
  prior(cauchy(0,2), class = 'sd')  +                  # for random effects - Site 
  prior(cauchy(0, 2), class = "sigma")  # for residual error (??)

heron_brm4_size_Spp <- brm(heron_size_turf,                 
                       data=heron,          
                       prior = priors,               
                       sample_prior = 'yes',           
                       iter = 5000,         
                       warmup = 1000,     
                       chains = 3, 
                       cores = 3,   
                       thin = 5,    
                       refresh = 0,            
                       control = list(adapt_delta = 0.99),   
                       backend = "rstan")  
  
  
# To save the model use >>  
#save(heron_brm4_size_Spp, file = "scripts/models/heron/size/heron_brm4_size_Spp.RData") 
```

Model diagnostics

```{r}
heron_brm4_size_Spp |> pp_check(type = 'dens_overlay', ndraws = 100) 
heron_brm4_size_Spp |> pp_check (type = "error_scatter_avg") 
heron_brm4_size_Spp  |> pp_check(group = 'Site', type = 'violin_grouped') 

#heron.resids4 <- make_brms_dharma_res(heron_brm4_size_Spp, integerResponse = FALSE)
#testUniformity(heron.resids4) 
#plotResiduals(heron.resids4)
#testDispersion(heron.resids4)
```

##### brm5 - sedconcrete_t2

```{r}
heron_size_concrete <-  bf(Size_log ~ sedconcrete_t2 * Spp + (1|Site) + (1|ReefDev), family = gaussian())  

priors <- prior(normal(0, 5), class = "Intercept") +  # for intercept   
  prior(normal(0,5), class = "b") +                   # for fixed effects - sedconcrete, Spp, interaction
  prior(cauchy(0,2), class = 'sd') +                  # for random effects - Site and ReefDev
  prior(cauchy(0, 2), class = "sigma")                # for residual error (??)

heron_brm5_size_Spp <- brm(heron_size_concrete,                 
                       data=heron,          
                       prior = priors,               
                       sample_prior = 'yes',           
                       iter = 5000,         
                       warmup = 1000,     
                       chains = 3, 
                       cores = 3,   
                       thin = 5,    
                       refresh = 0,            
                       control = list(adapt_delta = 0.99),   
                       backend = "rstan")  
  

# To save the model use >>  
#save(heron_brm5_size_Spp, file = "scripts/models/heron/size/heron_brm5_size_Spp.RData")
```

Model diagnostics

```{r}
heron_brm5_size_Spp |> pp_check(type = 'dens_overlay', ndraws = 100) 
heron_brm5_size_Spp |> pp_check (type = "error_scatter_avg") 
heron_brm5_size_Spp  |> pp_check(group = 'Site', type = 'violin_grouped') 

#heron.resids5 <- make_brms_dharma_res(heron_brm5_size_Spp, integerResponse = FALSE)
#testUniformity(heron.resids5) 
#plotResiduals(heron.resids5)
#testDispersion(heron.resids5)
```

##### brm6 - habitat

```{r}
heron_size_habitat <-  bf(Size_log ~ (PC1 * Spp) + (PC2 * Spp) + (1|Site) + (1|ReefDev), family = gaussian())  

priors <- prior(normal(0, 5), class = "Intercept") +  # for intercept   
  prior(normal(0,5), class = "b") +                   # for fixed effects - PC1 and PC2, Spp, and interaction
  prior(cauchy(0,2), class = 'sd')+                   # for random effects - Site and ReefDev
  prior(cauchy(0,2), class = "sigma")                 # for residual error (??)

heron_brm6_size_Spp <- brm(heron_size_habitat,                 
                       data=heron,          
                       prior = priors,               
                       sample_prior = 'yes',           
                       iter = 5000,         
                       warmup = 1000,     
                       chains = 3, 
                       cores = 3,   
                       thin = 5,    
                       refresh = 0,            
                       control = list(adapt_delta = 0.99),   
                       backend = "rstan")  

# To save the model use >>  
#save(heron_brm6_size_Spp, file = "scripts/models/heron/size/heron_brm6_size_Spp.RData")
```

Model diagnostics

```{r}
heron_brm6_size_Spp |> pp_check(type = 'dens_overlay', ndraws = 100) 
heron_brm6_size_Spp |> pp_check (type = "error_scatter_avg") 
heron_brm6_size_Spp  |> pp_check(group = 'Site', type = 'violin_grouped') 

#heron.resids6 <- make_brms_dharma_res(heron_brm6_size_Spp, integerResponse = FALSE)
#testUniformity(heron.resids6) 
#plotResiduals(heron.resids6)
#testDispersion(heron.resids6)
```

NOTES ON THIS:

The models fit the data well, as indicated by the graphical posterior predictive checks and non-significant uniformity and dispersion tests. The residuals appear to be normally distributed and homoscedastic, further supporting the adequacy of the models. The violin plots reveal that the models can capture site-specific effects, demonstrating the importance of including random intercepts for `Site`.

### Load models

```{r}
# OR with Species fixed effect: 
load(file = "scripts/models/heron/size/heron_brm0_size_Spp.RData")
load(file = "scripts/models/heron/size/heron_brm1_size_Spp.RData") 
load(file = "scripts/models/heron/size/heron_brm2_size_Spp.RData") 
load(file = "scripts/models/heron/size/heron_brm3_size_Spp.RData") 
load(file = "scripts/models/heron/size/heron_brm4_size_Spp.RData") 
load(file = "scripts/models/heron/size/heron_brm5_size_Spp.RData") 
load(file = "scripts/models/heron/size/heron_brm6_size_Spp.RData")
load(file = "scripts/models/heron/size/heron_brm7_size_Spp_sed.RData")
load(file = "scripts/models/heron/size/heron_brm8_size_Spp_sedt2.RData")

#OR models with (1|Site/ReefDev) as random effect
#load(file = "scripts/models/heron/size/heron_brm1_size_nested.RData") 

#OR models with (1|ReefDev) as random effect
#load(file = "scripts/models/heron/size/heron_brm1_size_reefdev.RData") 
```

### Loo compare

```{r}
##---------- with Spp --------
l_wave_Spp <- heron_brm1_size_Spp |> loo() 
l_Ub_Spp <- heron_brm2_size_Spp |> loo()
l_speed_Spp <- heron_brm3_size_Spp |> loo() 
l_turf_Spp <- heron_brm4_size_Spp|> loo() 
l_concrete_Spp <- heron_brm5_size_Spp|> loo() 
l_habitat_Spp <- heron_brm6_size_Spp|> loo() 

looic(heron_brm0_size_Spp)      #  LOOIC: 359.02 [13.08]
looic(heron_brm1_size_Spp)      #  LOOIC: 358.30 [12.31]
looic(heron_brm2_size_Spp)      #  LOOIC: 357.69 [12.68]
looic(heron_brm3_size_Spp)      #  LOOIC: 355.26 [12.77]
looic(heron_brm4_size_Spp)      #  LOOIC: 357.63 [12.61]
looic(heron_brm5_size_Spp)      #  LOOIC: 355.71 [12.71]
looic(heron_brm6_size_Spp)      #  LOOIC: 356.98 [12.34]

l_speed_Spp
l_Ub_Spp 
l_wave_Spp 
l_turf_Spp 
l_concrete_Spp 
l_habitat_Spp
```

**NOTES ON THIS:**

**LOOIC (Leave-One-Out Information Criterion)**: A measure of the model's predictive accuracy. Lower LOOIC values indicate a better model.

**ELPD (Expected Log Predictive Density)**: A measure of the model's predictive performance. Higher ELPD values indicate a better model.

**Standard Error (SE)**: The standard error of the LOOIC or ELPD estimates. Pareto k values that are mostly below 0.5 indicates good reliability. Values between 0.5 and 0.7 are acceptable but suggest some caution.

The Pareto k diagnostics provide information about the reliability of the LOO estimates.

**\*\* Best Model**: heron_brm6_size_Spp [(habitat)]{.underline} is the best model based as it has the lowest LOOIC value (365.07) indicating it has the best predictive performance among the models compared.

### Summary

```{r}
summary(heron_brm0_size_Spp)
summary(heron_brm1_size_Spp) 
summary(heron_brm2_size_Spp) 
summary(heron_brm3_size_Spp) 
summary(heron_brm4_size_Spp) 
summary(heron_brm5_size_Spp) 
summary(heron_brm6_size_Spp)
```

**NOTES ON THIS:**

-   All models show good convergence with Rhat values equal to 1.00.

-   The effective sample sizes (Bulk_ESS and Tail_ESS) are sufficient for all parameters.

-   **Significant Effects: A tenuis** consistently shows a significant positive effect on `Size_log` across all models.

-   **Non-significant effects:** all other predictors (`WaveEnergyLevel`, `Ub_avrg`, `median_speed`, `sedturf_t2`, `sedconcrete_t2`, `PC1`, `PC2`) do not show significant effects on `Size_log`.

-   **Model fit**: All models converge well with Rhat values of 1.00 and sufficient effective sample sizes (Bulk_ESS and Tail_ESS).

# \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

# Descriptives

Descriptive figure of mean size per reef.

First re-create dataframe with three reefs and only rows with size values

```{r}
moore <- moore |> select(-c(sedturf_t2,sedconcrete_t2)) |>
  rename(sedturf = sedturf_t5,
         sedconcrete = sedconcrete_t5)
heron <- heron |> select(-c(sedturf_t5, sedconcrete_t5)) |>
    rename(sedturf = sedturf_t2,
         sedconcrete = sedconcrete_t2)
 
#heron <- heron |>
#  select(-median_speed_cat)

size_allreef <- bind_rows(heron, moore, davies)
str(size_allreef)
```

### Overall Descriptive Statistics by Reef

Groups data by `Reef`. Calculates the overall mean size (`overall_mean_size`), overall standard deviation of size (`overall_sd_size`), number of observations (`observations_count`), and number of unique devices (`devices_count`) for each reef.

```{r}
# Calculate overall average size and standard deviation
overall_summary <- size_allreef |>
  group_by(Reef, Spp) |>
  summarise(
    overall_mean_size = mean(Size, na.rm = TRUE),  # Overall mean size
    overall_sd_size = sd(Size, na.rm = TRUE),      # Overall standard deviation
    observations_count = n(),                      # Count the number of observations
    devices_count = n_distinct(ReefDev)            # Count the number of unique devices
  )

overall_summary
```

### Per Site Descriptive Statistics

Groups data by `Reef` and `Site`. Calculates the number of observations (`observations_count`), number of unique devices (`devices_count`), mean size (`mean_size`), and standard deviation of size (`sd_size`) for each site.

```{r}
# Calculate descriptive statistics for each site within each reef
size_summary_site <- size_allreef |>
  group_by(Reef, Site) |>
  summarise(
    observations_count = n(),  # Count the number of observations
    devices_count = n_distinct(ReefDev),  # Count the number of unique devices
    mean_size = mean(Size, na.rm = TRUE),  # Calculate the mean size, excluding NA values
    sd_size = sd(Size, na.rm = TRUE)  # Calculate the standard deviation of the size, excluding NA values
  )

size_summary_site
```

### Device Observations Count

Groups data by `Reef`, `ReefDev`, and `Site`. Calculates the number of observations (`observations_count`) for each device.

```{r}
# Count the number of observations per device
device_counts <- size_allreef |>
  group_by(Reef, Spp, ReefDev, Site) |>
  summarise(observations_count = n()) |>
  ungroup()
```

### Device Summary for Devices with 1, 2, or 3 Observations

Groups data by `Reef` and `observations_count`. Summarizes the number of devices (`devices_count`) and lists unique sites (`sites`) for devices with 1, 2, or 3 observations. Filters the summary to include only devices with 1, 2, or 3 observations.

```{r}
# Summarize the counts to find how many devices had 2 or 3 observations
device_summary <- device_counts |>
  group_by(Reef,Spp, observations_count) |>
  summarise(
    devices_count = n(),  # Count the number of devices
    sites = list(unique(Site))  # List of unique sites
  ) |>
  filter(observations_count %in% c(1,2, 3))  # Filter for devices with 2 or 3 observations

# Print the device summary
device_summary
```

# \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

# Descriptive figures

### Boxplot - growth by site for each reef

```{r}
# Reorder the levels of the Reef variable
size_allreef$Reef <- factor(size_allreef$Reef, levels = c("Moore", "Davies", "Heron"))

# Plot the average growth for each reef and species - BOXPLOT
plot_size_site <- ggplot(size_allreef, aes(x= Site, y = Size, color = Spp)) +
   geom_boxplot() +
  scale_color_manual(values = c("A. millepora" = "green", "A. hyacinthus" = "orange", "A. kenti" = "purple")) +
  facet_wrap(~Reef, scales = "free") +
  labs(x = "Site",
       y = "Coral Size (mm3)",
       color = "Species") +
  theme_bw() +
  ylim(0,150) +
   theme(panel.border = element_rect(color = "black", fill = NA),
        axis.line = element_line(color = "black"),
        axis.text = element_text(size = 12),
        axis.title = element_text(size = 13), 
        legend.text = element_text(size = 12),
        strip.text = element_blank())

plot_size_site
ggsave("Fig3b - Coral Size by site.jpeg", plot=plot_size_site, width = 14, height = 6, dpi = 300)
```

### Boxplot - growth for each reef (ignoring site)

```{r}
# Reorder the levels of the Reef variable
size_allreef$Reef <- factor(size_allreef$Reef, levels = c("Moore", "Davies", "Heron"))

# Plot the average growth for each reef and species - BOXPLOT
plot_size_reef <- ggplot(size_allreef, aes(x= Reef, y = Size, color = Spp)) +
   geom_boxplot() +
  scale_color_manual(values = c("A. millepora" = "green", "A. hyacinthus" = "orange", "A. kenti" = "purple")) +
  facet_wrap(~Reef, scales = "free") +
  labs(title = "Coral Size Distribution by Reef",
        y = "Coral Size (mm3)",
       color = "Species") +
  theme_bw() +
  ylim(0,150)
  theme(panel.border = element_rect(color = "black", fill = NA),
        axis.line = element_line(color = "black"),
        axis.text = element_text(size = 12),
        axis.title = element_text(size = 14), 
        legend.text = element_text(size = 12))

plot_size_reef
ggsave("Fig3c - Coral Size by reef.png", plot=plot_size_reef, width = 14, height = 6, dpi = 300)
```

# Bayes Figures

### \-\-\-\-- Moore\-\-\-\--

Select the environmental predictors for the plots, then create empty entries for Ahya and Aten so that they appear in the figure legends (for complete species representation), and then combine the new species data with the selected moore data.

```{r}
moore_variables <- moore |>
  select(c(Spp, Size_log, Ub_avrg, WaveEnergyLevel, sedturf_t5, sedconcrete_t5, median_speed))

moore_variables_new <- data.frame(
  Ub_avrg = NA,  # Use NA since there are no actual values
  WaveEnergyLevel = NA,
  sedturf_t5 = NA,
  sedconcrete_t5 = NA,
  median_speed = NA,
  Size_log = NA, 
  Spp = c("A. hyacinthus", "A. kenti")
)

# Combine the new species data with the original moore data
moore_combined <- rbind(moore_variables, moore_variables_new)

remove(moore_variables)
remove(moore_variables_new)
```

```{r}
# Add a new species entry for predictor dataframe
new_species_moore <- data.frame(
  Ub_avrg = rep(NA, length(10)),
  WaveEnergyLevel = rep(NA, length(10)),
  sedturf_t5 = rep(NA, length(10)),
  sedconcrete_t5 = rep(NA, length(10)),
  median_speed = rep(NA, length(10)),
  Spp = c("A. hyacinthus", "A. kenti"),
  Fitted = NA,  
  Lower = NA,   
  Upper = NA    
)

moore_brm1 <- new_species_moore |>
  select(c(WaveEnergyLevel, Spp, Fitted, Lower, Upper))
moore_brm2 <- new_species_moore |>
  select(c(Ub_avrg, Spp, Fitted, Lower, Upper))
moore_brm3 <- new_species_moore |>
  select(c(median_speed, Spp, Fitted, Lower, Upper))
moore_brm4 <- new_species_moore |>
  select(c(sedturf_t5, Spp, Fitted, Lower, Upper))
moore_brm5 <- new_species_moore |>
  select(c(sedconcrete_t5, Spp, Fitted, Lower, Upper))
```

##### Bottom Stress

Extract fitted values and predictors and create empty entries for Aten and Ahya for complete species representation in the figure legends:

```{r}
# Extract fitted values and predictors 
fitted_values_moore_brm2 <- fitted(moore_brm2_size, summary = FALSE)

predicted_data_moore_brm2 <- data.frame(  
  Ub_avrg = moore$Ub_avrg,  
  Spp = moore$Spp,  
  Fitted = apply(fitted_values_moore_brm2, 2, mean), 
  Lower = apply(fitted_values_moore_brm2, 2, function(x) quantile(x, 0.025)), 
  Upper = apply(fitted_values_moore_brm2, 2, function(x) quantile(x, 0.975)) )

# Combine the new species data with the original predicted data
predicted_data_moore_brm2 <- rbind(predicted_data_moore_brm2, moore_brm2)

predicted_data_moore_brm2 <- predicted_data_moore_brm2 |>
  group_by(Ub_avrg) |>
  summarise(
    Fitted = mean(Fitted, na.rm = TRUE),
    Lower = mean(Lower, na.rm = TRUE),
    Upper = mean(Upper, na.rm = TRUE)
  )
```

Create plot:

```{r}
# Create the plot with points, error bars, and raw data
plot_moore_Ub<- ggplot() +
  geom_jitter(data = moore_combined, aes(x = Ub_avrg, y = Size_log, color = Spp), alpha = 0.5, width = 0.008, height = 0) +
  geom_errorbar(data = predicted_data_moore_brm2, aes(x = Ub_avrg, ymin = Lower, ymax = Upper), color = "black", width = 0.01, alpha = 0.5) +
  geom_point(data = predicted_data_moore_brm2, aes(x = Ub_avrg, y = Fitted), color = "black") +
   labs(
     color = "Species",
    fill = "Species") +
    scale_color_manual(values = c("A. hyacinthus" = "orange", "A. kenti" = "purple", "A. millepora" = "green")) +
  theme_minimal() +
     xlab("Bottom stress\n(m s-1)")+
  theme( axis.text.x = element_text(size = 12),  # Increase x-axis tick label size
  axis.text.y = element_text(size = 12),  # Increase y-axis tick label size.
  axis.title.x = element_text(size = 13),  # Increase x-axis title size
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.ticks.length = unit(0.25, "cm"),
     axis.title.y = element_blank()
  )
 

plot(plot_moore_Ub)
```

##### WaveEnergyLevel

Extract fitted values and predictors:

```{r}
# Extract fitted values and predictors 
fitted_values_moore_brm1 <- fitted(moore_brm1_size, summary = FALSE)

predicted_data_moore_brm1 <- data.frame(  
  WaveEnergyLevel = moore$WaveEnergyLevel,  
  Spp = moore$Spp,  
  Fitted = apply(fitted_values_moore_brm1, 2, mean), 
  Lower = apply(fitted_values_moore_brm1, 2, function(x) quantile(x, 0.025)), 
  Upper = apply(fitted_values_moore_brm1, 2, function(x) quantile(x, 0.975)) )

# Combine the new species data with the original predicted data
predicted_data_moore_brm1 <- rbind(predicted_data_moore_brm1, moore_brm1)

predicted_data_moore_brm1 <- predicted_data_moore_brm1 |>
  group_by(WaveEnergyLevel) |>
  summarise(
    Fitted = mean(Fitted, na.rm = TRUE),
    Lower = mean(Lower, na.rm = TRUE),
    Upper = mean(Upper, na.rm = TRUE)
  )
```

Create plot:

```{r}
# Create the plot with points, error bars, and raw data
plot_moore_WaveEnergyLevel <- ggplot() +
  # Plot the raw data points, colored in green
  geom_jitter(data = moore_combined, aes(x = WaveEnergyLevel, y = Size_log, color = Spp), alpha = 0.5, width = 0.1, height = 0) +
  geom_errorbar(data = predicted_data_moore_brm1, aes(x = WaveEnergyLevel, ymin = Lower, ymax = Upper), color = "black", width = 0.1, alpha = 0.5) +
  geom_point(data = predicted_data_moore_brm1, aes(x = WaveEnergyLevel, y = Fitted), color = "black") +
   labs(
    x = "Wave Energy Level",
    y = "Predicted growth log (mm3)",
    color = "Species",
    fill = "Species") +
   scale_color_manual(values = c("A. hyacinthus" = "orange", "A. kenti" = "purple", "A. millepora" = "green")) +
  theme_minimal() +
    xlab("Nom. Wave Energy Level")+
   theme( axis.text.x = element_text(size = 12),  # Increase x-axis tick label size
  axis.text.y = element_text(size = 12),  # Increase y-axis tick label size.
  axis.title.x = element_text(size = 13),  # Increase x-axis title size
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.ticks.length = unit(0.25, "cm"),
     axis.title.y = element_blank()
  )

plot(plot_moore_WaveEnergyLevel)
```

##### Flow velocity

Extract fitted values and predictors:

```{r}
# Extract fitted values and predictors 
fitted_values_moore_brm3 <- fitted(moore_brm3_size, summary = FALSE)

predicted_data_moore_brm3 <- data.frame(  
  median_speed = moore$median_speed,  
  Spp = moore$Spp,  
  Fitted = apply(fitted_values_moore_brm3, 2, mean), 
  Lower = apply(fitted_values_moore_brm3, 2, function(x) quantile(x, 0.025)), 
  Upper = apply(fitted_values_moore_brm3, 2, function(x) quantile(x, 0.975)) 
)

# Combine the new species data with the original predicted data
predicted_data_moore_brm3 <- rbind(predicted_data_moore_brm3, moore_brm3)

predicted_data_moore_brm3 <- predicted_data_moore_brm3 |>
  group_by(median_speed) |>
  summarise(
    Fitted = mean(Fitted, na.rm = TRUE),
    Lower = mean(Lower, na.rm = TRUE),
    Upper = mean(Upper, na.rm = TRUE)
  )
```

Create plot:

```{r}
# Create the plot with points, error bars, and raw data
plot_moore_speed<- ggplot() +
  geom_jitter(data = moore_combined, aes(x = median_speed, y = Size_log, color = Spp), alpha = 0.5, width = 0.0025, height = 0) +
  geom_errorbar(data = predicted_data_moore_brm3, aes(x = median_speed, ymin = Lower, ymax = Upper), color = "black", width = 0.0025, alpha = 0.5) +
  geom_point(data = predicted_data_moore_brm3, aes(x = median_speed, y = Fitted), color = "black") +
   labs(
     
    x = "Median flow velocity\n(m s-1)",
    y = "Predicted growth (mm3)",
    color = "Species",
    fill = "Species") +
    scale_color_manual(values = c("A. hyacinthus" = "orange", "A. kenti" = "purple", "A. millepora" = "green")) +
  theme_minimal() +
  theme( axis.text.x = element_text(size = 12),  # Increase x-axis tick label size
  axis.text.y = element_text(size = 12),  # Increase y-axis tick label size.
  axis.title.x = element_text(size = 13),  # Increase x-axis title size
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.ticks.length = unit(0.25, "cm"),
     axis.title.y = element_blank()
       )
 
plot(plot_moore_speed)
```

##### Sedturf

Extract fitted values and predictors:

```{r}
# Extract fitted values and predictors 
fitted_values_moore_brm4 <- fitted(moore_brm4_size, summary = FALSE)

predicted_data_moore_brm4 <- data.frame(  
  sedturf_t5 = moore$sedturf_t5,  
  Spp = moore$Spp,  
  Fitted = apply(fitted_values_moore_brm4, 2, mean), 
  Lower = apply(fitted_values_moore_brm4, 2, function(x) quantile(x, 0.025)), 
  Upper = apply(fitted_values_moore_brm4, 2, function(x) quantile(x, 0.975)) 
  )

# Combine the new species data with the original predicted data
predicted_data_moore_brm4 <- rbind(predicted_data_moore_brm4, moore_brm4)

predicted_data_moore_brm4 <- predicted_data_moore_brm4 |>
  group_by(sedturf_t5) |>
  summarise(
    Fitted = mean(Fitted, na.rm = TRUE),
    Lower = mean(Lower, na.rm = TRUE),
    Upper = mean(Upper, na.rm = TRUE)
  )
```

Create plot:

```{r}
# Create the plot with points, error bars, and raw data
plot_moore_turf <- ggplot() +
  # Plot the raw data points, colored in green
  geom_jitter(data = moore_combined, aes(x = sedturf_t5, y = Size_log, color = Spp), alpha = 0.5, width = 0.08, height = 0) +
  geom_errorbar(data = predicted_data_moore_brm4, aes(x = sedturf_t5, ymin = Lower, ymax = Upper), color = "black", width = 0.08, alpha = 0.5) +
  geom_point(data = predicted_data_moore_brm4, aes(x = sedturf_t5, y = Fitted), color = "black") +
     labs(
     
     x = "Sedimentation on turf \n(mg cm-2)",
    y = "Predicted growth (mm3)",
    color = "Species",
    fill = "Species") +
    scale_color_manual(values = c("A. hyacinthus" = "orange", "A. kenti" = "purple", "A. millepora" = "green")) +
  theme_minimal() +
   theme( axis.text.x = element_text(size = 12),  # Increase x-axis tick label size
  axis.text.y = element_text(size = 12),  # Increase y-axis tick label size.
  axis.title.x = element_text(size = 13),  # Increase x-axis title size
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.ticks.length = unit(0.25, "cm"),
     axis.title.y = element_blank()
  )

plot(plot_moore_turf)
```

##### Sedconcrete

```{r}
# Extract fitted values and predictors 
fitted_values_moore_brm5 <- fitted(moore_brm5_size, summary = FALSE)

predicted_data_moore_brm5 <- data.frame(  
  sedconcrete_t5 = moore$sedconcrete_t5,  
  Spp = moore$Spp,  
  Fitted = apply(fitted_values_moore_brm5, 2, mean), 
  Lower = apply(fitted_values_moore_brm5, 2, function(x) quantile(x, 0.025)), 
  Upper = apply(fitted_values_moore_brm5, 2, function(x) quantile(x, 0.975)) 
)

# Combine the new species data with the original predicted data
predicted_data_moore_brm5 <- rbind(predicted_data_moore_brm5, moore_brm5)

predicted_data_moore_brm5 <- predicted_data_moore_brm5 |>
  group_by(sedconcrete_t5) |>
  summarise(
    Fitted = mean(Fitted, na.rm = TRUE),
    Lower = mean(Lower, na.rm = TRUE),
    Upper = mean(Upper, na.rm = TRUE)
  )
```

```{r}
# Create the plot with points, error bars, and raw data
plot_moore_concrete <- ggplot() +
  # Plot the raw data points, colored in green
  geom_jitter(data = moore_combined, aes(x = sedconcrete_t5, y = Size_log, color = Spp), alpha = 0.5, width = 0.02, height = 0) +
  geom_errorbar(data = predicted_data_moore_brm5, aes(x = sedconcrete_t5, ymin = Lower, ymax = Upper), color = "black", width = 0.05, alpha = 0.5) +
  geom_point(data = predicted_data_moore_brm5, aes(x = sedconcrete_t5, y = Fitted), color = "black") +
   labs(
      x = "Sedimentation on concrete \n(mg cm-2)",
    y = "Predicted growth (mm3)",
    color = "Species",
    fill = "Species") +
    scale_color_manual(values = c("A. hyacinthus" = "orange", "A. kenti" = "purple", "A. millepora" = "green")) +
  theme_minimal() +
    theme( axis.text.x = element_text(size = 12),  # Increase x-axis tick label size
  axis.text.y = element_text(size = 12),  # Increase y-axis tick label size.
  axis.title.x = element_text(size = 13),  # Increase x-axis title size
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.ticks.length = unit(0.25, "cm"),
     axis.title.y = element_blank()
  )

plot(plot_moore_concrete)
```

### \-\-\-\-- Davies\-\-\-\--

```{r}
davies_variables <- davies |>
  select(c(Spp, Size_log, Ub_avrg, WaveEnergyLevel, sedturf, sedconcrete, median_speed))

davies_variables_new <- data.frame(
  Ub_avrg = NA,  # Use NA since there are no actual values
  WaveEnergyLevel = NA,
  sedturf = NA,
  sedconcrete = NA,
  median_speed = NA,
  Size_log = NA, 
  Spp = c("A. millepora", "A. kenti")
)

# Combine the new species data with the original davies data
davies_combined <- rbind(davies_variables, davies_variables_new)

remove(davies_variables)
remove(davies_variables_new)
```

```{r}
# Add a new species entry for predictor dataframe
new_species_davies <- data.frame(
  Ub_avrg = rep(NA, length(10)),
  WaveEnergyLevel = rep(NA, length(10)),
  sedturf = rep(NA, length(10)),
  sedconcrete = rep(NA, length(10)),
  median_speed = rep(NA, length(10)),
  Spp = c("A. millepora", "A. kenti"),
  Fitted = NA,  
  Lower = NA,   
  Upper = NA    
)

davies_brm1 <- new_species_davies |>
  select(c(WaveEnergyLevel, Spp, Fitted, Lower, Upper))
davies_brm2 <- new_species_davies |>
  select(c(Ub_avrg, Spp, Fitted, Lower, Upper))
davies_brm3 <- new_species_davies |>
  select(c(median_speed, Spp, Fitted, Lower, Upper))
davies_brm4 <- new_species_davies |>
  select(c(sedturf, Spp, Fitted, Lower, Upper))
davies_brm5 <- new_species_davies |>
  select(c(sedconcrete, Spp, Fitted, Lower, Upper))
```

##### Bottom Stress

Extract fitted values and predictors:

```{r}
# Extract fitted values and predictors 
fitted_values_davies_brm2 <- fitted(davies_brm2_size, summary = FALSE)

predicted_data_davies_brm2 <- data.frame(  
  Ub_avrg = davies$Ub_avrg,  
  Spp = davies$Spp,  
  Fitted = apply(fitted_values_davies_brm2, 2, mean), 
  Lower = apply(fitted_values_davies_brm2, 2, function(x) quantile(x, 0.025)), 
  Upper = apply(fitted_values_davies_brm2, 2, function(x) quantile(x, 0.975)) )

# Combine the new species data with the original predicted data
predicted_data_davies_brm2 <- rbind(predicted_data_davies_brm2, davies_brm2)

predicted_data_davies_brm2 <- predicted_data_davies_brm2 |>
  group_by(Ub_avrg) |>
  summarise(
    Fitted = mean(Fitted, na.rm = TRUE),
    Lower = mean(Lower, na.rm = TRUE),
    Upper = mean(Upper, na.rm = TRUE)
  )
```

Create plot:

```{r}
# Create the plot with points, error bars, and raw data
plot_davies_Ub<- ggplot() +
  geom_jitter(data = davies_combined, aes(x = Ub_avrg, y = Size_log, color = Spp), alpha = 0.5, width = 0.008, height = 0) +
  geom_errorbar(data = predicted_data_davies_brm2, aes(x = Ub_avrg, ymin = Lower, ymax = Upper), color = "black", width = 0.01, alpha = 0.5) +
  geom_point(data = predicted_data_davies_brm2, aes(x = Ub_avrg, y = Fitted), color = "black") +
   labs(
       x = "Bottom stress (m/s)",
    y = "Predicted growth (mm3)",
    color = "Species",
    fill = "Species") +
    scale_color_manual(values = c("A. hyacinthus" = "orange", "A. kenti" = "purple", "A. millepora" = "green")) +
  theme_minimal() +
   xlab("Bottom stress\n(m s-1)")+
   theme( axis.text.x = element_text(size = 12),  # Increase x-axis tick label size
  axis.text.y = element_text(size = 12),  # Increase y-axis tick label size.
  axis.title.x = element_text(size = 13),  # Increase x-axis title size
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.ticks.length = unit(0.25, "cm"),
     axis.title.y = element_blank()
  )

plot(plot_davies_Ub)
```

##### WaveEnergyLevel

Extract fitted values and predictors:

```{r}
# Extract fitted values and predictors 
fitted_values_davies_brm1 <- fitted(davies_brm1_size, summary = FALSE)

predicted_data_davies_brm1 <- data.frame(  
  WaveEnergyLevel = davies$WaveEnergyLevel,  
  Spp = davies$Spp,  
  Fitted = apply(fitted_values_davies_brm2, 2, mean), 
  Lower = apply(fitted_values_davies_brm2, 2, function(x) quantile(x, 0.025)), 
  Upper = apply(fitted_values_davies_brm2, 2, function(x) quantile(x, 0.975)) )

# Combine the new species data with the original predicted data
predicted_data_davies_brm1 <- rbind(predicted_data_davies_brm1, davies_brm1)

predicted_data_davies_brm1 <- predicted_data_davies_brm1 |>
  group_by(WaveEnergyLevel) |>
  summarise(
    Fitted = mean(Fitted, na.rm = TRUE),
    Lower = mean(Lower, na.rm = TRUE),
    Upper = mean(Upper, na.rm = TRUE)
  )
```

Create plot:

```{r}
# Create the plot with points, error bars, and raw data
plot_davies_WaveEnergyLevel <- ggplot() +
  # Plot the raw data points, colored in green
  geom_jitter(data = davies_combined, aes(x = WaveEnergyLevel, y = Size_log, color = Spp), alpha = 0.5, width = 0.1, height = 0) +
  geom_errorbar(data = predicted_data_davies_brm1, aes(x = WaveEnergyLevel, ymin = Lower, ymax = Upper), color = "black", width = 0.1, alpha = 0.5) +
  geom_point(data = predicted_data_davies_brm1, aes(x = WaveEnergyLevel, y = Fitted), color = "black") +
   labs(
        x = "Wave Energy Level",
    y = "Predicted growth (mm3)",
    color = "Species",
    fill = "Species") +
   scale_color_manual(values = c("A. hyacinthus" = "orange", "A. kenti" = "purple", "A. millepora" = "green")) +
  theme_minimal() +
    xlab("Nom. Wave Energy Level")+
  theme( axis.text.x = element_text(size = 12),  # Increase x-axis tick label size
  axis.text.y = element_text(size = 12),  # Increase y-axis tick label size.
  axis.title.x = element_text(size = 13),  # Increase x-axis title size
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.ticks.length = unit(0.25, "cm"),
     axis.title.y = element_blank()
  )

plot(plot_davies_WaveEnergyLevel)
```

##### Flow velocity

Extract fitted values and predictors:

```{r}
# Extract fitted values and predictors 
fitted_values_davies_brm3 <- fitted(davies_brm3_size, summary = FALSE)

predicted_data_davies_brm3 <- data.frame(  
  median_speed = davies$median_speed,  
  Spp = davies$Spp,  
  Fitted = apply(fitted_values_davies_brm2, 2, mean), 
  Lower = apply(fitted_values_davies_brm2, 2, function(x) quantile(x, 0.025)), 
  Upper = apply(fitted_values_davies_brm2, 2, function(x) quantile(x, 0.975)) )

# Combine the new species data with the original predicted data
predicted_data_davies_brm3 <- rbind(predicted_data_davies_brm3, davies_brm3)

predicted_data_davies_brm3 <- predicted_data_davies_brm3 |>
  group_by(median_speed) |>
  summarise(
    Fitted = mean(Fitted, na.rm = TRUE),
    Lower = mean(Lower, na.rm = TRUE),
    Upper = mean(Upper, na.rm = TRUE)
  )
```

Create plot:

```{r}
# Create the plot with points, error bars, and raw data
plot_davies_speed<- ggplot() +
  geom_jitter(data = davies_combined, aes(x = median_speed, y = Size_log, color = Spp), alpha = 0.5, width = 0.0025, height = 0) +
  geom_errorbar(data = predicted_data_davies_brm3, aes(x = median_speed, ymin = Lower, ymax = Upper), color = "black", width = 0.0025, alpha = 0.5) +
  geom_point(data = predicted_data_davies_brm3, aes(x = median_speed, y = Fitted), color = "black") +
   labs(
       x = "Median flow velocity\n(m s-1)",
    y = "Predicted growth (mm3)",
    color = "Species",
    fill = "Species") +
    scale_color_manual(values = c("A. hyacinthus" = "orange", "A. kenti" = "purple", "A. millepora" = "green")) +
  theme_minimal() +
  theme( axis.text.x = element_text(size = 12),  # Increase x-axis tick label size
  axis.text.y = element_text(size = 12),  # Increase y-axis tick label size.
  axis.title.x = element_text(size = 13),  # Increase x-axis title size
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.ticks.length = unit(0.25, "cm"),
     axis.title.y = element_blank()
  )

plot(plot_davies_speed)
```

##### Sedturf

Extract fitted values and predictors:

```{r}
# Extract fitted values and predictors 
fitted_values_davies_brm4 <- fitted(davies_brm4_size, summary = FALSE)

predicted_data_davies_brm4 <- data.frame(  
  sedturf = davies$sedturf,  
  Spp = davies$Spp,  
  Fitted = apply(fitted_values_davies_brm4, 2, mean), 
  Lower = apply(fitted_values_davies_brm4, 2, function(x) quantile(x, 0.025)), 
  Upper = apply(fitted_values_davies_brm4, 2, function(x) quantile(x, 0.975)) )

# Combine the new species data with the original predicted data
predicted_data_davies_brm4 <- rbind(predicted_data_davies_brm4, davies_brm4)

predicted_data_davies_brm4 <- predicted_data_davies_brm4 |>
  group_by(sedturf) |>
  summarise(
    Fitted = mean(Fitted, na.rm = TRUE),
    Lower = mean(Lower, na.rm = TRUE),
    Upper = mean(Upper, na.rm = TRUE)
  )
```

Create plot:

```{r}
# Create the plot with points, error bars, and raw data
plot_davies_turf <- ggplot() +
  # Plot the raw data points, colored in green
  geom_jitter(data = davies_combined, aes(x = sedturf, y = Size_log, color = Spp), alpha = 0.5, width = 0.08, height = 0) +
  geom_errorbar(data = predicted_data_davies_brm4, aes(x = sedturf, ymin = Lower, ymax = Upper), color = "black", width = 0.08, alpha = 0.5) +
  geom_point(data = predicted_data_davies_brm4, aes(x = sedturf, y = Fitted), color = "black") +
   labs(
    x = "Sedimentation on turf (mg cm-2",
    y = "Predicted growth (mm3)",
    color = "Species",
    fill = "Species") +
    scale_color_manual(values = c("A. hyacinthus" = "orange", "A. kenti" = "purple", "A. millepora" = "green")) +
   xlab("Sedimentation on turf\n(mg cm-2)")+
  theme_minimal() +
   theme( axis.text.x = element_text(size = 12),  # Increase x-axis tick label size
  axis.text.y = element_text(size = 12),  # Increase y-axis tick label size.
  axis.title.x = element_text(size = 13),  # Increase x-axis title size
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.ticks.length = unit(0.25, "cm"),
     axis.title.y = element_blank()
  )

plot(plot_davies_turf)
```

##### Sedconcrete

```{r}
# Extract fitted values and predictors 
fitted_values_davies_brm5 <- fitted(davies_brm5_size, summary = FALSE)

predicted_data_davies_brm5 <- data.frame(  
  sedconcrete = davies$sedconcrete,  
  Spp = davies$Spp,  
  Fitted = apply(fitted_values_davies_brm5, 2, mean), 
  Lower = apply(fitted_values_davies_brm5, 2, function(x) quantile(x, 0.025)), 
  Upper = apply(fitted_values_davies_brm5, 2, function(x) quantile(x, 0.975)) )

# Combine the new species data with the original predicted data
predicted_data_davies_brm5 <- rbind(predicted_data_davies_brm5, davies_brm5)

predicted_data_davies_brm5 <- predicted_data_davies_brm5 |>
  group_by(sedconcrete) |>
  summarise(
    Fitted = mean(Fitted, na.rm = TRUE),
    Lower = mean(Lower, na.rm = TRUE),
    Upper = mean(Upper, na.rm = TRUE)
  )
```

Create plot:

```{r}
# Create the plot with points, error bars, and raw data
plot_davies_concrete <- ggplot() +
  # Plot the raw data points, colored in green
  geom_jitter(data = davies_combined, aes(x = sedconcrete, y = Size_log, color = Spp), alpha = 0.5, width = 0.02, height = 0) +
  geom_errorbar(data = predicted_data_davies_brm5, aes(x = sedconcrete, ymin = Lower, ymax = Upper), color = "black", width = 0.025, alpha = 0.5) +
  geom_point(data = predicted_data_davies_brm5, aes(x = sedconcrete, y = Fitted), color = "black") +
   labs(
        x = "Sedimentation on concrete\n(mg cm-2)",
    y = "Predicted growth (mm3)",
    color = "Species",
    fill = "Species") +
    scale_color_manual(values = c("A. hyacinthus" = "orange", "A. kenti" = "purple", "A. millepora" = "green")) +
  theme_minimal() +
  theme( axis.text.x = element_text(size = 12),  # Increase x-axis tick label size
  axis.text.y = element_text(size = 12),  # Increase y-axis tick label size.
  axis.title.x = element_text(size = 13),  # Increase x-axis title size
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.ticks.length = unit(0.25, "cm"),
     axis.title.y = element_blank()
  )

plot(plot_davies_concrete)
```

### \-\-\-\-- Heron\-\-\-\--

```{r}
heron_variables <- heron |>
  select(c(Spp, Size_log, Ub_avrg, WaveEnergyLevel, sedturf_t2, sedconcrete_t2,median_speed))

heron_variables_new <- data.frame(
  Ub_avrg = NA,  # Use NA since there are no actual values
  WaveEnergyLevel = NA,
  sedturf_t2 = NA,
  sedconcrete_t2 = NA,
  median_speed = NA,
  Size_log = NA, 
  Spp = c("A. millepora")
)

# Combine the new species data with the original heron data
heron_combined <- rbind(heron_variables, heron_variables_new)

remove(heron_variables)
remove(heron_variables_new)
```

```{r}
# Add a new species entry for predictor dataframe
new_species_heron <- data.frame(
  Ub_avrg = rep(NA, length(10)),
  WaveEnergyLevel = rep(NA, length(10)),
  sedturf_t2 = rep(NA, length(10)),
  sedconcrete_t2 = rep(NA, length(10)),
  median_speed = rep(NA, length(10)),
  Spp = c("A. millepora"),
  Fitted = NA,  
  Lower = NA,   
  Upper = NA    
)

heron_brm1 <- new_species_heron |>
  select(c(WaveEnergyLevel, Spp, Fitted, Lower, Upper))
heron_brm2 <- new_species_heron |>
  select(c(Ub_avrg, Spp, Fitted, Lower, Upper))
heron_brm3 <- new_species_heron |>
  select(c(median_speed, Spp, Fitted, Lower, Upper))
heron_brm4 <- new_species_heron |>
  select(c(sedturf_t2, Spp, Fitted, Lower, Upper))
heron_brm5 <- new_species_heron |>
  select(c(sedconcrete_t2, Spp, Fitted, Lower, Upper))
```

##### Bottom Stress

Extract fitted values and predictors:

```{r}
# Extract fitted values and predictors
fitted_values_heron_brm2 <- fitted(heron_brm2_size_Spp, summary = FALSE)
predicted_data_heron_brm2 <- data.frame(
  Ub_avrg = heron$Ub_avrg,
  Spp = heron$Spp,
  Fitted = apply(fitted_values_heron_brm2, 2, mean),
  Lower = apply(fitted_values_heron_brm2, 2, function(x) quantile(x, 0.025)),
  Upper = apply(fitted_values_heron_brm2, 2, function(x) quantile(x, 0.975))
)

# Combine the new species data with the original predicted data
predicted_data_heron_brm2 <- rbind(predicted_data_heron_brm2, heron_brm2)

predicted_data_heron_brm2 <- predicted_data_heron_brm2 |>
  group_by(Ub_avrg) |>
  summarise(
    Fitted = mean(Fitted, na.rm = TRUE),
    Lower = mean(Lower, na.rm = TRUE),
    Upper = mean(Upper, na.rm = TRUE)
  )
```

Create plot:

```{r}
# Create the plot with points, error bars, and raw data
plot_heron_Ub<- ggplot() +
  geom_jitter(data = heron_combined, aes(x = Ub_avrg, y = Size_log, color = Spp), alpha = 0.5, width = 0.008, height = 0) +
  geom_errorbar(data = predicted_data_heron_brm2, aes(x = Ub_avrg, ymin = Lower, ymax = Upper), color = "black", width = 0.01, alpha = 0.5) +
  geom_point(data = predicted_data_heron_brm2, aes(x = Ub_avrg, y = Fitted), color = "black") +
   labs(
   
    x = "Bottom stress (m/s)",
    y = "Predicted growth (mm3)",
    color = "Species",
    fill = "Species") +
    scale_color_manual(values = c("A. hyacinthus" = "orange", "A. kenti" = "purple", "A. millepora" = "green")) +
  theme_minimal() +
 theme( axis.text.x = element_text(size = 12),  # Increase x-axis tick label size
  axis.text.y = element_text(size = 12),  # Increase y-axis tick label size.
  axis.title.x = element_text(size = 13),  # Increase x-axis title size
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.ticks.length = unit(0.25, "cm"),
     axis.title.y = element_blank()
  ) + 
    xlab("Bottom stress\n(m s-1)")


plot(plot_heron_Ub)
```

##### WaveEnergyLevel

Extract fitted values and predictors:

```{r}
# Extract fitted values and predictors
fitted_values_heron_brm1 <- fitted(heron_brm1_size_Spp, summary = FALSE)
predicted_data_heron_brm1 <- data.frame(
  WaveEnergyLevel = heron$WaveEnergyLevel,
  Spp = heron$Spp,
  Fitted = apply(fitted_values_heron_brm1, 2, mean),
  Lower = apply(fitted_values_heron_brm1, 2, function(x) quantile(x, 0.025)),
  Upper = apply(fitted_values_heron_brm1, 2, function(x) quantile(x, 0.975))
)

# Combine the new species data with the original predicted data
predicted_data_heron_brm1 <- rbind(predicted_data_heron_brm1, heron_brm1)

predicted_data_heron_brm1 <- predicted_data_heron_brm1 |>
  group_by(WaveEnergyLevel) |>
  summarise(
    Fitted = mean(Fitted, na.rm = TRUE),
    Lower = mean(Lower, na.rm = TRUE),
    Upper = mean(Upper, na.rm = TRUE)
  )
```

Create plot:

```{r}
# Create the plot with points, error bars, and raw data
plot_heron_WaveEnergyLevel <- ggplot() +
  # Plot the raw data points, colored in green
  geom_jitter(data = heron_combined, aes(x = WaveEnergyLevel, y = Size_log, color = Spp), alpha = 0.5, width = 0.1, height = 0) +
  geom_errorbar(data = predicted_data_heron_brm1, aes(x = WaveEnergyLevel, ymin = Lower, ymax = Upper), color = "black", width = 0.1, alpha = 0.5) +
  geom_point(data = predicted_data_heron_brm1, aes(x = WaveEnergyLevel, y = Fitted), color = "black") +
   labs(
    
    x = "Wave Energy Level",
    y = "Predicted growth (mm3)",
    color = "Species",
    fill = "Species") +
   scale_color_manual(values = c("A. hyacinthus" = "orange", "A. kenti" = "purple", "A. millepora" = "green")) +
  theme_minimal() +
   theme( axis.text.x = element_text(size = 12),  # Increase x-axis tick label size
  axis.text.y = element_text(size = 12),  # Increase y-axis tick label size.
  axis.title.x = element_text(size = 13),  # Increase x-axis title size
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.ticks.length = unit(0.25, "cm"),
     axis.title.y = element_blank()
  ) + 
  xlab("Nom. Wave Energy Level")

plot(plot_heron_WaveEnergyLevel)
```

##### Flow velocity

Extract fitted values and predictors:

```{r}
# Extract fitted values and predictors
fitted_values_heron_brm3 <- fitted(heron_brm3_size_Spp, summary = FALSE)
predicted_data_heron_brm3 <- data.frame(
  median_speed = heron$median_speed,
  Spp = heron$Spp,
  Fitted = apply(fitted_values_heron_brm3, 2, mean),
  Lower = apply(fitted_values_heron_brm3, 2, function(x) quantile(x, 0.025)),
  Upper = apply(fitted_values_heron_brm3, 2, function(x) quantile(x, 0.975))
)

# Combine the new species data with the original predicted data
predicted_data_heron_brm3 <- rbind(predicted_data_heron_brm3, heron_brm3)

predicted_data_heron_brm3 <- predicted_data_heron_brm3 |>
  group_by(median_speed) |>
  summarise(
    Fitted = mean(Fitted, na.rm = TRUE),
    Lower = mean(Lower, na.rm = TRUE),
    Upper = mean(Upper, na.rm = TRUE)
  )
```

Create plot:

```{r}
# Create the plot with points, error bars, and raw data
plot_heron_speed<- ggplot() +
  geom_jitter(data = heron_combined, aes(x = median_speed, y = Size_log, color = Spp), alpha = 0.5, width = 0.0025, height = 0) +
  geom_errorbar(data = predicted_data_heron_brm3, aes(x = median_speed, ymin = Lower, ymax = Upper), color = "black", width = 0.0025, alpha = 0.5) +
  geom_point(data = predicted_data_heron_brm3, aes(x = median_speed, y = Fitted), color = "black") +
   labs(
   
    x = "Median flow velocity (m/s)",
    y = "Predicted growth (mm3)",
    color = "Species",
    fill = "Species") +
    scale_color_manual(values = c("A. hyacinthus" = "orange", "A. kenti" = "purple", "A. millepora" = "green")) +
  theme_minimal() +
  theme( axis.text.x = element_text(size = 12),  # Increase x-axis tick label size
  axis.text.y = element_text(size = 12),  # Increase y-axis tick label size.
  axis.title.x = element_text(size = 13),  # Increase x-axis title size
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.ticks.length = unit(0.25, "cm"),
     axis.title.y = element_blank()
  ) + 
  xlab("Median flow velocity\n(m s-1)")

plot(plot_heron_speed)
```

##### Sedturf

Extract fitted values and predictors:

```{r}
# Extract fitted values and predictors
fitted_values_heron_brm4 <- fitted(heron_brm4_size_Spp, summary = FALSE)
predicted_data_heron_brm4 <- data.frame(
  sedturf_t2 = heron$sedturf_t2,
  Spp = heron$Spp,
  Fitted = apply(fitted_values_heron_brm4, 2, mean),
  Lower = apply(fitted_values_heron_brm4, 2, function(x) quantile(x, 0.025)),
  Upper = apply(fitted_values_heron_brm4, 2, function(x) quantile(x, 0.975))
)

# Combine the new species data with the original predicted data
predicted_data_heron_brm4 <- rbind(predicted_data_heron_brm4, heron_brm4)

predicted_data_heron_brm4 <- predicted_data_heron_brm4 |>
  group_by(sedturf_t2) |>
  summarise(
    Fitted = mean(Fitted, na.rm = TRUE),
    Lower = mean(Lower, na.rm = TRUE),
    Upper = mean(Upper, na.rm = TRUE)
  )
```

Create plot:

```{r}
# Create the plot with points, error bars, and raw data
plot_heron_turf <- ggplot() +
  # Plot the raw data points, colored in green
  geom_jitter(data = heron_combined, aes(x = sedturf_t2, y = Size_log, color = Spp), alpha = 0.5, width = 0.08, height = 0) +
  geom_errorbar(data = predicted_data_heron_brm4, aes(x = sedturf_t2, ymin = Lower, ymax = Upper), color = "black", width = 0.5, alpha = 0.5) +
  geom_point(data = predicted_data_heron_brm4, aes(x = sedturf_t2, y = Fitted), color = "black") +
   labs(
    
    x = "Sedimentation on turf (mg cm-2)",
    y = "Predicted growth (mm3)",
    color = "Species",
    fill = "Species") +
    scale_color_manual(values = c("A. hyacinthus" = "orange", "A. kenti" = "purple", "A. millepora" = "green")) +
  theme_minimal() +
   theme( axis.text.x = element_text(size = 12),  # Increase x-axis tick label size
  axis.text.y = element_text(size = 12),  # Increase y-axis tick label size.
  axis.title.x = element_text(size = 13),  # Increase x-axis title size
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.ticks.length = unit(0.25, "cm"),
     axis.title.y = element_blank()
  ) + 
  xlab("Sedimentation on turf\n(mg cm-2)")

plot(plot_heron_turf)
```

##### Sedconcrete

```{r}
# Extract fitted values and predictors
fitted_values_heron_brm5 <- fitted(heron_brm5_size_Spp, summary = FALSE)
predicted_data_heron_brm5 <- data.frame(
  sedconcrete_t2 = heron$sedconcrete_t2,
  Spp = heron$Spp,
  Fitted = apply(fitted_values_heron_brm4, 2, mean),
  Lower = apply(fitted_values_heron_brm4, 2, function(x) quantile(x, 0.025)),
  Upper = apply(fitted_values_heron_brm4, 2, function(x) quantile(x, 0.975))
)

# Combine the new species data with the original predicted data
predicted_data_heron_brm5 <- rbind(predicted_data_heron_brm5, heron_brm5)

predicted_data_heron_brm5 <- predicted_data_heron_brm5 |>
  group_by(sedconcrete_t2) |>
  summarise(
    Fitted = mean(Fitted, na.rm = TRUE),
    Lower = mean(Lower, na.rm = TRUE),
    Upper = mean(Upper, na.rm = TRUE)
  )
```

```{r}
# Create the plot with points, error bars, and raw data
plot_heron_concrete <- ggplot() +
  # Plot the raw data points, colored in green
  geom_jitter(data = heron_combined, aes(x = sedconcrete_t2, y = Size_log, color = Spp), alpha = 0.5, width = 0.05, height = 0) +
  geom_errorbar(data = predicted_data_heron_brm5, aes(x = sedconcrete_t2, ymin = Lower, ymax = Upper), color = "black", width = 0.1, alpha = 0.5) +
  geom_point(data = predicted_data_heron_brm5, aes(x = sedconcrete_t2, y = Fitted), color = "black") +
   labs(
   
    x = "Sedimentation on concrete (mg cm-2)",
    y = "Predicted growth (mm3)",
    color = "Species",
    fill = "Species") +
    scale_color_manual(values = c("A. hyacinthus" = "orange", "A. kenti" = "purple", "A. millepora" = "green")) +
  theme_minimal() +
   theme( axis.text.x = element_text(size = 12),  # Increase x-axis tick label size
  axis.text.y = element_text(size = 12),  # Increase y-axis tick label size.
  axis.title.x = element_text(size = 13),  # Increase x-axis title size
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.ticks.length = unit(0.25, "cm"),
     axis.title.y = element_blank()
  ) + 
  xlab("Sedimentation on concrete\n(mg cm-2)")

plot(plot_heron_concrete)
```

### \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

### Save figures:

### Moore

```{r}
setwd("C:/Users/sjurriaa/Australian Institute of Marine Science/Carly Randall - Randall Lab/CAD/CAD Year1/")
ggsave("output/figures growth/Moore Predicted growth Ub.jpeg", plot_moore_Ub, width = 10, height = 6)
ggsave("output/figures growth/Moore Predicted growth WaveEnergyLevel.jpeg", plot_moore_WaveEnergyLevel, width = 10, height = 6)
ggsave("output/figures growth/Moore Predicted growth Median Speed.jpeg", plot_moore_speed, width = 10, height = 6)
ggsave("output/figures growth/Moore Predicted growth Turf.jpeg", plot_moore_turf, width = 10, height = 6)
ggsave("output/figures growth/Moore Predicted growth Concrete.jpeg", plot_moore_concrete, width = 10, height = 6)
```

### Davies

```{r}
setwd("C:/Users/sjurriaa/Australian Institute of Marine Science/Carly Randall - Randall Lab/CAD/CAD Year1/")
ggsave("output/figures growth/Davies Predicted growth Ub.jpeg", plot_davies_Ub, width = 10, height = 6)
ggsave("output/figures growth/Davies Predicted growth WaveEnergyLevel.jpeg", plot_davies_WaveEnergyLevel, width = 10, height = 6)
ggsave("output/figures growth/Davies Predicted growth Median Speed.jpeg", plot_davies_speed, width = 10, height = 6)
ggsave("output/figures growth/Davies Predicted growth Turf.jpeg", plot_davies_turf, width = 10, height = 6)
ggsave("output/figures growth/Davies Predicted growth Concrete.jpeg", plot_davies_concrete, width = 10, height = 6)
```

### Heron

```{r}
setwd("C:/Users/sjurriaa/Australian Institute of Marine Science/Carly Randall - Randall Lab/CAD/CAD Year1/")
ggsave("output/figures growth/Heron Predicted growth Ub.jpeg", plot_heron_Ub, width = 4, height = 4)
ggsave("output/figures growth/Heron Predicted growth WaveEnergyLevel.jpeg", plot_heron_WaveEnergyLevel, width = 4, height = 4)
ggsave("output/figures growth/Heron Predicted growth Median Speed.jpeg", plot_heron_speed, width = 4, height = 4)
ggsave("output/figures growth/Heron Predicted growth Turf.jpeg", plot_heron_turf, width = 4, height = 4)
ggsave("output/figures growth/Heron Predicted growth Concrete.jpeg", plot_heron_concrete, width = 4, height = 4)
```

### Multiplot figure

Shared legend

```{r}
grid_arrange_shared_legend <-
  function(...,
           ncol = length(list(...)),
           nrow = 1,
           position = c("bottom", "right")) {
    
    plots <- list(...)
    position <- match.arg(position)
    g <-
      ggplotGrob(plots[[1]] + theme(legend.position = position))$grobs
    legend <- g[[which(sapply(g, function(x)
      x$name) == "guide-box")]]
    lheight <- sum(legend$height)
    lwidth <- sum(legend$width)
    gl <- lapply(plots, function(x)
      x + theme(legend.position = "none"))
    gl <- c(gl, ncol = ncol, nrow = nrow)
    
    combined <- switch(
      position,
      "bottom" = arrangeGrob(
        do.call(arrangeGrob, gl),
        legend,
        ncol = 1,
        heights = unit.c(unit(1, "npc") - lheight, lheight)
      ),
      "right" = arrangeGrob(
        do.call(arrangeGrob, gl),
        legend,
        ncol = 2,
        widths = unit.c(unit(1, "npc") - lwidth, lwidth)
      )
    )
    
    grid.newpage()
    grid.draw(combined)
    
    # return gtable invisibly
    invisible(combined)
    
  }
```

```{r}
capture_plot <- function() {
  grid_arrange_shared_legend(
  plot_moore_WaveEnergyLevel,plot_davies_WaveEnergyLevel,plot_heron_WaveEnergyLevel,
  plot_moore_Ub,plot_davies_Ub,plot_heron_Ub,
  plot_moore_speed,plot_davies_speed,plot_heron_speed,
  plot_moore_turf,plot_davies_turf,plot_heron_turf,
  plot_moore_concrete,plot_davies_concrete,plot_heron_concrete,
             ncol = 3, 
             nrow = 5)
}

capture_plot()
```

```{r}
# Save the plot using ggsave
ggsave("Figure Multiplot Growth AllReefs.jpeg", plot = capture_plot(), width = 9, height = 12)
```
