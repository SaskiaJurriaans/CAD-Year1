---
title: "Bayes_Heron_Yield"
edits: "Edits made in scripts following meeting with Murray 17/04/2024"
author: "Sas"
format: html
editor: visual
---

# Preparations

Load the necessary libraries

```{r}
#| label: libraries
#| output: false
#| eval: true
#| warning: false
#| message: false
#| cache: false

library(tidyverse)  #for data wrangling etc
library(rstanarm)   #for fitting models in STAN
#library(cmdstanr)   #for cmdstan --> does not work on AIMS computers
library(brms)       #for fitting models in STAN
library(standist)   #for exploring distributions
library(coda)       #for diagnostics
library(bayesplot)  #for diagnostics
library(ggmcmc)     #for MCMC diagnostics
library(DHARMa)     #for residual diagnostics
library(rstan)      #for interfacing with STAN
library(emmeans)    #for marginal means etc
library(broom)      #for tidying outputs
library(tidybayes)  #for more tidying outputs
library(HDInterval) #for HPD intervals
library(ggeffects)  #for partial plots
library(broom.mixed)#for summarising models
library(posterior)  #for posterior draws
library(ggeffects)  #for partial effects plots
library(patchwork)  #for multi-panel figures
library(bayestestR) #for ROPE
library(see)        #for some plots
library(readxl)     #to load excel documents
library(easystats)     #framework for stats, modelling and visualisation
#library(INLA)       #for approximate Bayes
library(openxlsx)    # to write excel documents
#library(INLAutils)  #for additional INLA outputs
theme_set(theme_grey()) #put the default ggplot theme back
source('helperFunctions.R')
```

# Read in the data

```{r}
survival <- read_excel("data/YEAR1_Survival.xlsx", na ="")

environment <- read_excel ("data/YEAR1 Benthic Environment ReefDev.xlsx", na="")
```

# Exploratory data

```{r}
glimpse(survival)
head(survival)
str(survival)
survival |> datawizard::data_codebook()
```

Remove some unnecessary columns

```{r}
survival <- survival |>
  select(-c(ID, Observer, CensusT, DeploymentDate, CensusDate, Device_ID, NoRecruits))
```

# Heron Spp

### Subset data: Heron Spp

Focus on Heron Reef only

```{r}
heron_surv <- survival |> filter (Reef == "Heron")

heron_surv <- heron_surv[complete.cases(heron_surv$SurvDev),  ]
```

Create a dataframe that groups to device level (not tab level) and then gives a survival score (SurvDev_Spp) if the species had a survivor on the device (one surviving tab). Also create a new column for total tabs on the device of that species (either 1 or 2).

```{r}
# first for A tenuis
heron_Aten <- heron_surv |> 
  filter(Spp == "A_tenuis") |>
  group_by(Census, ReefDev) |>
  mutate(SurvDev_Spp = ifelse(any(SurvTab == 1), 1, 0),
         Total_Spp = n()) |>
  ungroup()

heron_Aten2 <- heron_Aten |>
  group_by(Census, ReefDev) |>
  summarise(ExpDay = first(ExpDay),
            Reef = first(Reef),
            Site = first(Site),
            WaveEnergyLevel = first(WaveEnergyLevel),
            Spp = first(Spp),
            Total_Spp = first(Total_Spp),
            SurvDev_Spp = max(SurvDev_Spp)) |>
  ungroup()

# now for Ahyacinthus
heron_Ahya <- heron_surv |> 
  filter(Spp == "A_hyacinthus") |>
  group_by(Census, ReefDev) |>
  mutate(SurvDev_Spp = ifelse(any(SurvTab == 1), 1, 0),
         Total_Spp = n()) |>
  ungroup()

heron_Ahya2 <- heron_Ahya |>
  group_by(Census, ReefDev) |>
  summarise(ExpDay = first(ExpDay),
            Reef = first(Reef),
            Site = first(Site),
            WaveEnergyLevel = first(WaveEnergyLevel),
            Spp = first(Spp),
            Total_Spp = first(Total_Spp),
            SurvDev_Spp = max(SurvDev_Spp)) |>
  ungroup()

#bind them together to create one dataframe
heron_Spp <- rbind(heron_Ahya2, heron_Aten2)
heron_Spp <- heron_Spp |>
  arrange(Census, Site, Spp, ReefDev)

#free up space
remove(heron_Aten, heron_Aten2, heron_Ahya, heron_Ahya2)
```

### Merge survival and environment

```{r}
heron_Spp_t3 <- heron_Spp |>
  filter(Census == "t3")

heron_env <- environment |>
  filter(Reef == "Heron") |>
  select(-c(Reef1, Device_ID))
```

```{r}
heron_Spp <- merge(heron_env, heron_Spp, by = c("Reef", "Site", "ReefDev"), all = TRUE)
heron_Spp_t3 <- merge(heron_env, heron_Spp_t3, by = c("Reef", "Site", "ReefDev"), all = TRUE)

#free up space
remove(heron_surv, heron_env)
```

```{r}
# Remove rows with missing values
heron_Spp_t3$SurvDev_Spp <- as.numeric(heron_Spp_t3$SurvDev_Spp)
heron_Spp_t3 <- heron_Spp_t3[complete.cases(heron_Spp_t3$SurvDev_Spp),  ]
heron_Spp_t3 <- heron_Spp_t3 |> select(-c(sedturf_t5, sedconcrete_t5))

# Remove rows with missing values
heron_Spp$SurvDev_Spp <- as.numeric(heron_Spp$SurvDev_Spp)
heron_Spp <- heron_Spp[complete.cases(heron_Spp$SurvDev_Spp),  ]
heron_Spp <- heron_Spp |> select(-c(sedturf_t5, sedconcrete_t5))
```

### GLM

```{r}
library(lme4)
heron_Spp_t3$Site <- as.factor(heron_Spp_t3$Site)
heron_Spp_t3$ReefDev<- as.factor(heron_Spp_t3$ReefDev)
heron_Spp_t3$Spp<- as.factor(heron_Spp_t3$Spp)
heron_Spp$Census<-as.factor(heron_Spp$Census)

heronSpp_glmer1<- glmer(SurvDev_Spp ~ (1|Site) + (1|ReefDev), data=heron_Spp_t3, family = binomial(link = "logit"))
heronSpp_glmer2<- glmer(SurvDev_Spp ~ (1|Site) + (Spp|ReefDev), data=heron_Spp_t3, family = binomial(link = "logit"))
heronSpp_glmer3<- glmer(SurvDev_Spp ~ Spp + (1|Site) + (1|ReefDev), data=heron_Spp_t3, family = binomial(link = "logit"))
heronSpp_glmer4<- glmer(SurvDev_Spp ~ Spp + (1|Site) + (Spp|ReefDev), data=heron_Spp_t3, family = binomial(link = "logit"))

heronSpp_glmer5<- glmer(SurvDev_Spp ~ Ub_avrg + (1|Site) + (1|ReefDev), data=heron_Spp_t3, family = binomial(link = "logit"))
heronSpp_glmer6<- glmer(SurvDev_Spp ~ WaveEnergyLevel + (1|Site) + (1|ReefDev), data=heron_Spp_t3, family = binomial(link = "logit"))
heronSpp_glmer7<- glmer(SurvDev_Spp ~ median_speed + (1|Site) + (1|ReefDev), data=heron_Spp_t3, family = binomial(link = "logit"))
heronSpp_glmer8<- glmer(SurvDev_Spp ~ sedturf_t2 + (1|Site) + (1|ReefDev), data=heron_Spp_t3, family = binomial(link = "logit"))

heronSpp_glmer9<- glmer(SurvDev_Spp ~ Spp + (1|Site) + (1|ReefDev) + Census, data=heron_Spp, family = binomial(link = "logit"))

summary(heronSpp_glmer1)
summary(heronSpp_glmer2)
summary(heronSpp_glmer3)
summary(heronSpp_glmer4)
summary(heronSpp_glmer9)
AIC(heronSpp_glmer1, heronSpp_glmer2, heronSpp_glmer3, heronSpp_glmer4, heronSpp_glmer5, heronSpp_glmer6, heronSpp_glmer7, heronSpp_glmer8, heronSpp_glmer9)
```

### Visualize data

```{r}
ggplot(data=heron_Spp_t3, aes(y = SurvDev_Spp, x = WaveEnergyLevel)) + 
  geom_point(position = position_jitter(width = 0.2, height = 0)) +
  facet_wrap(~Spp) + 
  geom_smooth(method="lm")
```

```{r}
ggplot(data=heron_Spp_t3, aes(y = SurvDev_Spp, x = Ub_avrg)) + 
  geom_point(position = position_jitter(width = 0.2, height = 0)) +
  facet_wrap(~Spp) + 
  geom_smooth(method="lm")

ggplot(data=heron_Spp_t3, aes(y = SurvDev_Spp, x = median_speed)) + 
  geom_point(position = position_jitter(width = 0.2, height = 0)) +
  facet_wrap(~Spp) + 
  geom_smooth(method="lm")
```

# Heron Yield

### Subset data: Heron yield (device level)

```{r}
heron_surv_t3 <- survival |> filter (Reef == "Heron",
                             Census == "t3",
                             Tab_ID == 1) |>
  select(-c(Tab_ID, SurvTab, Spp))

heron_surv <- survival |> filter (Reef == "Heron",
                             Tab_ID == 1) |>
  select(-c(Tab_ID, SurvTab, Spp))

heron_env <- environment |> 
  filter (Reef == "Heron") |>
  select(-c(Reef1, Device_ID))
```

### Merge survival and environment

```{r}
heron_t3 <- merge(heron_env, heron_surv_t3, by = c("Reef", "Site", "ReefDev"), all = TRUE)
heron<- merge(heron_env, heron_surv, by = c("Reef", "Site", "ReefDev"), all = TRUE)

#free up space
remove(heron_surv, heron_env)

# Remove rows with missing values
heron_t3$SurvDev <- as.numeric(heron_t3$SurvDev)
heron_t3 <- heron_t3[complete.cases(heron_t3$SurvDev),  ]
heron_t3 <- heron_t3 |> select(-c(sedturf_t5, sedconcrete_t5))

# Remove rows with missing values
heron$SurvDev <- as.numeric(heron$SurvDev)
heron <- heron[complete.cases(heron$SurvDev),  ]
heron <- heron |> select(-c(sedturf_t5, sedconcrete_t5))
```

### GLM

Update 28/05/2024 - removed (1\|ReefDev) - do not need random effect of devices if not treating species

```{r}
library(lme4)
heron_t3$Site <- as.factor(heron_t3$Site)
heron_t3$ReefDev<- as.factor(heron_t3$ReefDev)

heron$Site <- as.factor(heron$Site)
heron$ReefDev<- as.factor(heron$ReefDev)

heron_glmer1<- glmer(SurvDev ~ (1|Site), data=heron_t3, family = binomial(link = "logit")) #allowing for random intercepts for different sites.

heron_glmer2<- glmer(SurvDev ~ (1|Site) + (1|ReefDev), data=heron_t3, family = binomial(link = "logit")) #allowing for random intercepts but not random slopes --> accounting for potential variability in survival beteeen different sites and devices, but assuming that the effect of device on  survival is constant across different sites.

heron_glmer3<- glmer(SurvDev ~ (1|Site) + Census, data=heron, family = binomial(link = "logit")) #include Census

heron_glmer4<- glmer(SurvDev ~ Ub_avrg + (1|Site), data=heron_t3, family = binomial(link = "logit")) 
heron_glmer5<- glmer(SurvDev ~ WaveEnergyLevel + (1|Site), data=heron_t3, family = binomial(link = "logit")) 
heron_glmer6<- glmer(SurvDev ~ median_speed + (1|Site), data=heron_t3, family = binomial(link = "logit")) 
heron_glmer7<- glmer(SurvDev ~ sedturf_t2 + (1|Site), data=heron_t3, family = binomial(link = "logit")) 

summary(heron_glmer1)
summary(heron_glmer2)
summary(heron_glmer3)
summary(heron_glmer4)
summary(heron_glmer5)
summary(heron_glmer6)
summary(heron_glmer7)

AIC(heronSpp_glmer3, heronSpp_glmer4, heron_glmer1, heron_glmer2, heron_glmer3, heron_glmer4, heron_glmer5,heron_glmer6,heron_glmer7)
```

OUTPUT: Census time adds more complexity and explains less variatin. Without census, all models behave very similar and are better than a model with species in it

### Visualize data

**median_speed**

```{r}
ggplot(data=heron_t3, aes(y = SurvDev, x = median_speed)) + 
  geom_point(position = position_jitter(width = 0.2, height = 0)) +
  geom_smooth(method="lm")

ggplot(data=heron_t3, aes(y = SurvDev, x = median_speed)) + 
  geom_point(position = position_jitter(width = 0.2, height = 0)) +
  geom_smooth(method="lm", formula = y~poly(x,3), se = FALSE)

#with facetwrap by site
ggplot(data=heron_t3, aes(y = SurvDev, x = median_speed)) + 
  geom_point(position = position_jitter(width = 0.2, height = 0)) +
  facet_wrap(~Site) +
  geom_smooth(method="lm")
```

Wave Energy Level

```{r}
ggplot(data=heron_t3, aes(y = SurvDev, x = WaveEnergyLevel)) + 
  geom_point(position = position_jitter(width = 0.2, height = 0)) +
  geom_smooth(method="lm")

ggplot(data=heron_t3, aes(y = SurvDev, x = WaveEnergyLevel)) + 
  geom_point(position = position_jitter(width = 0.2, height = 0)) +
  geom_smooth(method="lm", formula = y~poly(x,3), se = FALSE)

#with facetwrap by site
ggplot(data=heron_t3, aes(y = SurvDev, x = WaveEnergyLevel)) + 
  geom_point(position = position_jitter(width = 0.2, height = 0)) +
  facet_wrap(~Site) +
  geom_smooth(method="lm")
```

```{r}
Heron_current <- ggplot(heron_t2, aes(x = median_speed, y = SurvDev)) +
  geom_point(position = position_jitter(width = 0.2, height = 0)) +
  geom_smooth(method="lm") +
  labs(title = "Heron Reef",
       x = "In-situ current - median speed (m/s)",
       y = "% Survival (yield)") +
  theme_bw() +
  ylim(0,1) +
  theme(panel.border = element_rect(color = "black", fill = NA),
        axis.line = element_line(color = "black"),
        axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) 

Heron_current

ggsave("Heron - Survival final census current - yield.png", plot=Heron_current, width = 4, height = 6, dpi = 600)
```

# Brm

We need to make sure that the categorical variables and the random effects are defined as factors:

```{r}
heron_t3 <- heron_t3 |> mutate(Site = factor(Site),
                               ReefDev = factor(ReefDev))
```

### Formulas

Logistic mixed-effects regression model with random intercepts for Site:

```{r}
heron_form <- bf(SurvDev ~ (1|Site), family = bernoulli(link='logit'))
heron_form_Spp_dev <- bf(SurvDev_Spp ~ Census * Spp + (1|Site) + (1|ReefDev), family = bernoulli(link='logit'))

heron_form_Spp<- bf(SurvDev_Spp ~ Census * Spp + (1|Site) + (Spp|ReefDev), family = bernoulli(link = "logit"))

heron_form_speed <- bf(SurvDev ~ median_speed + (1|Site), family = bernoulli(link='logit'))
heron_form_Ub <-    bf(SurvDev ~ Ub_avrg + (1|Site), family = bernoulli(link='logit'))
heron_form_turf <-   bf(SurvDev ~ sedturf_t2 + (1|Site), family = bernoulli(link='logit'))
heron_form_concrete <-bf(SurvDev ~ sedconcrete_t2 +(1|Site), family = bernoulli(link='logit'))
heron_form_Wave <-  bf(SurvDev ~ WaveEnergyLevel + (1|Site), family = bernoulli(link='logit'))
heron_form_PC <-   bf(SurvDev ~ PC1 + PC2 + (1|Site), family = bernoulli(link='logit'))
```

Now with polynomial terms:

```{r}
heron_form_speed_poly <- bf(SurvDev ~ poly(median_speed,3) +(1|Site), family = bernoulli(link='logit'))
heron_form_Ub_poly <-    bf(SurvDev ~ poly(Ub_avrg,3) +(1|Site), family = bernoulli(link='logit'))
heron_form_turf_poly <-   bf(SurvDev ~ poly(sedturf_t2,3) +(1|Site), family = bernoulli(link='logit'))
heron_form_Wave_poly <-  bf(SurvDev ~ poly(WaveEnergyLevel,3) +(1|Site), family = bernoulli(link='logit'))
heron_form_PC_poly <-   bf(SurvDev ~ poly(PC1,3) + poly(PC2,3) +(1|Site), family = bernoulli(link='logit'))
```

### Priors

class "Intercept" -\> for random effects

class "b" -\> for regression coefficent

class "sd" -\> for standard deviations of random effects

```{r}
priors <- prior(normal(0, 1.7), class = "Intercept") +
    prior(student_t(3, 0, 1.5), class = 'sd')
```

```{r}
priors_time <- prior(normal(0, 1.7), class = "Intercept") +
  prior(normal(0,5), class = "b") +
   prior(student_t(3, 0, 1.5), class = 'sd')
```

**median speed**

```{r}
2.5 * sd(heron_t3$SurvDev, na.rm = TRUE)/sd(heron_t3$median_speed, na.rm = TRUE)

priors_speed <- prior(normal(0, 1.7), class = "Intercept") +
  prior(normal(0,30), class = "b")  +
   prior(student_t(3, 0, 1.5), class = 'sd')
```

**Ub**

```{r}
2.5 * sd(heron_t3$SurvDev, na.rm = TRUE)/sd(heron_t3$Ub_avrg, na.rm = TRUE)

priors_Ub <- prior(normal(0, 1.7), class = "Intercept") +
  prior(normal(0,6), class = "b")  +
   prior(student_t(3, 0, 1.5), class = 'sd')
```

**turf**

```{r}
2.5 * sd(heron_t3$SurvDev, na.rm = TRUE)/sd(heron_t3$sedturf_t2, na.rm = TRUE)

priors_turf <- prior(normal(0, 1.7), class = "Intercept") +
  prior(normal(0,0.25), class = "b")  +
   prior(student_t(3, 0, 1.5), class = 'sd')
```

**concrete**

```{r}
2.5 * sd(heron_t3$SurvDev, na.rm = TRUE)/sd(heron_t3$sedconcrete_t2, na.rm = TRUE)

priors_concrete <- prior(normal(0, 1.7), class = "Intercept") +
  prior(normal(0,1.2), class = "b")  +
   prior(student_t(3, 0, 1.5), class = 'sd')
```

**WaveEnergyLevel**

```{r}
2.5 * sd(heron_t3$SurvDev, na.rm = TRUE)/sd(heron_t3$WaveEnergyLevel, na.rm = TRUE)

priors_wave <- prior(normal(0, 1.7), class = "Intercept") +
  prior(normal(0,1), class = "b")  +
   prior(student_t(3, 0, 1.5), class = 'sd')

```

**PC**

```{r}
2.5 * sd(heron_t3$SurvDev, na.rm = TRUE)/sd(heron_t3$PC1, na.rm = TRUE)
2.5 * sd(heron_t3$SurvDev, na.rm = TRUE)/sd(heron_t3$PC2, na.rm = TRUE)

priors_PC <- prior(normal(0, 1.7), class = "Intercept") +
  prior(normal(0,8), class = "b")  +  
   prior(student_t(3, 0, 1.5), class = 'sd')
```

### brm1- Random effects + time

```{r}
heron_form_time <- bf(SurvDev ~ Census + (1|Site), family = bernoulli(link='logit'))

priors_time <- prior(normal(0, 1.7), class = "Intercept") +
  prior(normal(0,5), class = "b") +
   prior(student_t(3, 0, 1.5), class = 'sd')

heron_brm1 <- brm(heron_form_time,
                 data=heron,
                 prior = priors_time,
                 sample_prior = 'yes',
                 iter = 5000,
                 warmup = 1000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.9),
                backend = "rstan")

# To save the model use >> 
#save(heron_brm1, file = "scripts/models/heron_brm1.RData")
```

### brm2- Random effects: time \* Spp + device

```{r}
heron_form_Spp_dev <- bf(SurvDev_Spp ~ Census * Spp + (1|Site) + (1|ReefDev), family = bernoulli(link='logit'))

priors <- prior(normal(0, 1.7), class = "Intercept") +
    prior(student_t(3, 0, 1.5), class = 'sd')

heron_brm2 <- brm(heron_form_Spp_dev,
                 data=heron_Spp,
                 prior = priors,
                 sample_prior = 'yes',
                 iter = 8000,
                 warmup = 2000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.9),
                backend = "rstan")
#save the model
#save(heron_brm2, file = "scripts/models/heron_brm2.RData")
```

### brm3- Random effects: time \* Spp + Spp\|device

```{r}
heron_form_Spp<- bf(SurvDev_Spp ~ Census * Spp + (1|Site) + (Spp|ReefDev), family = bernoulli(link = "logit"))

priors <- prior(normal(0, 1.7), class = "Intercept") +
    prior(student_t(3, 0, 1.5), class = 'sd')

heron_brm3<- brm(heron_form_Spp,
                 data=heron_Spp,
                 prior = priors,
                 sample_prior = 'yes',
                 iter = 8000,
                 warmup = 2000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.9),
                backend = "rstan")
#save the model
#save(heron_brm3, file = "scripts/models/heron_brm3.RData")
```

### brm4- time \* Wave

```{r}
heron_form_time_Wave <-  bf(SurvDev ~ Census + WaveEnergyLevel + (1|Site), family = bernoulli(link='logit'))

heron_brm4 <- brm(heron_form_time_Wave,
                 data=heron,
                 prior = priors_time,
                 sample_prior = 'yes',
                 iter = 5000,
                 warmup = 1000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.9),
                backend = "rstan")

# To save the model use >> 
#save(heron_brm4, file = "scripts/models/heron_brm4.RData")

```

### brm5- time \* Ub

```{r}
heron_form_time_Ub <-  bf(SurvDev ~ Census + Ub_avrg + (1|Site), family = bernoulli(link='logit'))

heron_brm5 <- brm(heron_form_time_Ub,
                 data=heron,
                 prior = priors_time,
                 sample_prior = 'yes',
                 iter = 5000,
                 warmup = 1000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.9),
                backend = "rstan")

# To save the model use >> 
#save(heron_brm5, file = "scripts/models/heron_brm5.RData")
```

### brm6- time \* Current

```{r}
heron_form_time_Speed <-  bf(SurvDev ~ Census + median_speed + (1|Site), family = bernoulli(link='logit'))

heron_brm6 <- brm(heron_form_time_Speed,
                 data=heron,
                 prior = priors_time,
                 sample_prior = 'yes',
                 iter = 5000,
                 warmup = 1000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.9),
                backend = "rstan")

# To save the model use >> 
#save(heron_brm6, file = "scripts/models/heron_brm6.RData")
```

### brm7- time \* turf

```{r}
heron_form_time_turf <-  bf(SurvDev ~ Census + sedturf_t2 + (1|Site), family = bernoulli(link='logit'))

heron_brm7 <- brm(heron_form_time_turf,
                 data=heron,
                 prior = priors_turf,
                 sample_prior = 'yes',
                 iter = 5000,
                 warmup = 1000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.9),
                backend = "rstan")

# To save the model use >> 
#save(heron_brm7, file = "scripts/models/heron_brm7.RData")
```

### brm8- time \* concrete

```{r}
heron_form_time_concrete <-  bf(SurvDev ~ Census + sedconcrete_t2 + (1|Site), family = bernoulli(link='logit'))

heron_brm8 <- brm(heron_form_time_concrete,
                 data=heron,
                 prior = priors_concrete,
                 sample_prior = 'yes',
                 iter = 5000,
                 warmup = 1000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.9),
                backend = "rstan")

# To save the model use >> 
#save(heron_brm8, file = "scripts/models/heron_brm8.RData")
```

### brm9- time \* habitat

```{r}
heron_form_time_PCA <-   bf(SurvDev ~ Census +PC1 + PC2 + (1|Site), family = bernoulli(link='logit'))

heron_brm9 <- brm(heron_form_time_PCA,
                 data=heron,
                 prior = priors_PC,
                 sample_prior = 'yes',
                 iter = 5000,
                 warmup = 1000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.9),
                backend = "rstan")

# Save the model 
#save(heron_brm9, file = "scripts/models/heron_brm9.RData")
```

### brm10- Random effects only t3

```{r}
heron_brm <- brm(heron_form,
                 data=heron_t3,
                 prior = priors,
                 sample_prior = 'yes',
                 iter = 5000,
                 warmup = 1000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.9),
                backend = "rstan")

# To save the model use >> 
#save(heron_brm, file = "scripts/models/heron_brm.RData")
```

### brm11- Random effects (t3): Spp + 1\|device

```{r}
heron_t3_form_Spp_dev<- bf(SurvDev_Spp ~ Spp + (1|Site) + (1|ReefDev), family = bernoulli(link = "logit"))

heron_brm_t3_Spp_dev<- brm(heron_t3_form_Spp_dev,
                 data=heron_Spp_t3,
                 prior = priors,
                 sample_prior = 'yes',
                 iter = 8000,
                 warmup = 2000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.9),
                backend = "rstan")
#save the model
#save(heron_brm_t3_Spp_dev, file = "scripts/models/heron_brm_t3_Spp_dev.RData")

```

### brm12- Random effects (t3): Spp + Spp\|device

```{r}
heron_t3_form_Spp<- bf(SurvDev_Spp ~ Spp + (1|Site) + (Spp|ReefDev), family = bernoulli(link = "logit"))

heron_brm_t3_Spp<- brm(heron_t3_form_Spp,
                 data=heron_Spp_t3,
                 prior = priors,
                 sample_prior = 'yes',
                 iter = 8000,
                 warmup = 2000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.9),
                backend = "rstan")
#save the model
#save(heron_brm_t3_Spp, file = "scripts/models/heron_brm_t3_Spp.RData")

```

### brm15- t3 - speed

```{r}
heron_brm_speed <- brm(heron_form_speed,
                 data=heron_t3,
                 prior = priors_speed,
                 sample_prior = 'yes',
                 iter = 5000,
                 warmup = 1000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.9),
                 backend = "rstan")

# Save the model
#save(heron_brm_speed, file = "scripts/models/heron_brm_speed.RData")
```

### brm14 - t3 - Ub

```{r}
heron_brm_Ub <- brm(heron_form_Ub,
                 data=heron_t3,
                 prior = priors_Ub,
                 sample_prior = 'yes',
                 iter = 5000,
                 warmup = 1000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.9),
                backend = "rstan")

# Save the model
#save(heron_brm_Ub, file = "scripts/models/heron_brm_Ub.RData")
```

### brm13-t3 - wave

```{r}
heron_form_Wave <-  bf(SurvDev ~ WaveEnergyLevel + (1|Site), family = bernoulli(link='logit'))

heron_brm_wave <- brm(heron_form_Wave,
                 data=heron_t3,
                 prior = priors_wave,
                 sample_prior = 'yes',
                 iter = 5000,
                 warmup = 1000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.9),
                backend = "rstan")

# Save the model
#save(heron_brm_wave, file = "scripts/models/heron_brm_wave.RData")
```

### brm16 - t3- turf

```{r}
heron_brm_turf <- brm(heron_form_turf,
                 data=heron_t3,
                 prior = priors_turf,
                 sample_prior = 'yes',
                 iter = 5000,
                 warmup = 1000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.9),
                backend = "rstan")

# Save the model 
#save(heron_brm_turf, file = "scripts/models/heron_brm_turf.RData")
```

### brm17 - t3 - concrete

```{r}
heron_brm_concrete <- brm(heron_form_concrete,
                 data=heron_t3,
                 prior = priors_concrete,
                 sample_prior = 'yes',
                 iter = 5000,
                 warmup = 1000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.9),
                backend = "rstan")

# Save the model 
#save(heron_brm_concrete, file = "scripts/models/heron_brm_concrete.RData")
```

### brm18 - t3 - PCA

```{r}
heron_form_PCA <-   bf(SurvDev ~ PC1 + PC2 + (1|Site), family = bernoulli(link='logit'))

priors_PCA <- prior(normal(0, 1.7), class = "Intercept") +
  prior(normal(0,8), class = "b")  +  
   prior(student_t(3, 0, 1.5), class = 'sd')

heron_brm_PCA <- brm(heron_form_PCA,
                 data=heron_t3,
                 prior = priors_PCA,
                 sample_prior = 'yes',
                 iter = 5000,
                 warmup = 1000,
                 chains = 3, cores = 3,
                 thin = 5,
                 refresh = 0,
                 control = list(adapt_delta = 0.9),
                backend = "rstan")

# Save the model 
#save(heron_brm_PCA, file = "scripts/models/heron_brm_PCA.RData")
```

### Load models

```{r}
load(file = "scripts/models/heron_brm.RData")
load(file = "scripts/models/heron_brm_speed.RData")
load(file = "scripts/models/heron_brm_Ub.RData")
load(file = "scripts/models/heron_brm_wave.RData")
load(file = "scripts/models/heron_brm_turf.RData")
load(file = "scripts/models/heron_brm_concrete.RData")
load(file = "scripts/models/heron_brm_PCA.RData")
```

### loo

```{r}
#Using loo compare, lower value is better
l_brm <- heron_brm |> loo()
l_device <- heron_brm_device |> loo()
l_Spp <- heron_brm_Spp |> loo()
l_speed <- heron_brm_speed|> loo()
l_Ub <- heron_brm_Ub |> loo()
l_wave <- heron_brm_wave |> loo()
l_turf <- heron_brm_turf|> loo()
l_concrete <- heron_brm_concrete|> loo()
l_PC <- heron_brm_PCA |> loo()

loo_compare(l_speed, l_Ub, l_wave, l_turf, l_concrete)
```

NOTES ON THIS: Prefer the model with the lower LOOIC, as it suggests better expected out-of-sample predictive performance. However, consider the uncertainty (SE) around these estimates. Significance of Differences: Look at the differences in LOOIC and their standard errors. A rule of thumb is that a difference greater than twice its standard error might be considered substantial, but this is not a strict threshold. If two models have similar LOOIC values, the simpler model (the one with fewer parameters) is typically preferred due to the principle of parsimony. This is not directly shown in the loo_compare() output but is an important consideration when interpreting results.

# Diagnostics

### brm

#### **MCMC**

```{r}
#pars <- heron_brm |> get_variables()  #capture the list of variables
pars <- str_extract(pars, "^b_.*|^sd.*") |> na.omit()
pars

heron_brm $fit |> stan_trace(pars = pars)
heron_brm $fit |> stan_ac(pars = pars)
heron_brm$fit |> stan_rhat()
heron_brm$fit |> stan_ess()  # the closer to 1, the more chains have converged
heron_brm |> mcmc_plot(type='violin')  # assess convergence and mixing of MCMC samples and skewness of the distribution
```

-   **stan_ac**: All below 0.25, all good.
-   **rhat_hist**: Rhat is a **scale reduction factor** measure of convergence between the chains. The closer the values are to 1, the more the chains have converged. Values greater than 1.05 indicate a lack of convergence. There will be an Rhat value for each parameter estimated.
-   **stan_ess:** effective sample size not very efficient, most below 50%.

#### **Posterior probability checks**

```{r}
heron_brm |> pp_check(type = 'dens_overlay', ndraws = 100)
heron_brm |> pp_check (type = "error_scatter_avg")
heron_brm  |> pp_check(group = 'Site', type = 'violin_grouped')
```

-   **dens_overlay**: plots the density distribution of the observed data (black line) overlayed ontop of 50 density distributions generated from draws from the model (light blue). Ideally, the 50 realisations should be roughly consistent with the observed data.
-   **error_scatter_avg**: this plots the observed values against the average residuals. Similar to a residual plot, we do not want to see any patterns in this plot. Note, this is not really that useful for models that involve a binomial response
-   **intervals**: plots the observed data overlayed ontop of posterior predictions associated with each level of the predictor. Ideally, the observed data should all fall within the predictive intervals.

#### **dHARMA residuals**

```{r}
library(DHARMa)
heron.resids <- make_brms_dharma_res(heron_brm, integerResponse = FALSE)
testUniformity(heron.resids)
```

```{r}
wrap_elements(~testUniformity(heron.resids))
wrap_elements(~plotResiduals(heron.resids, form = factor(rep(1,nrow(heron_t3))))) 
wrap_elements(~plotResiduals(heron.resids, quantreg = TRUE))   # leave the quartile calculations off if you have a small amount of data
wrap_elements(~testDispersion(heron.resids))
```

**Conclusions:**

-   the simulated residuals do not suggest any issues with the residuals
-   there is no evidence of a lack of fit.

### brm- Speed

#### **MCMC**

```{r}
pars <- heron_brm_speed |> get_variables()  #capture the list of variables
pars <- str_extract(pars, "^b_.*|^sd.*") |> na.omit()
pars

heron_brm_speed$fit |> stan_trace(pars = pars)
heron_brm_speed$fit |> stan_ac(pars = pars)
heron_brm_speed$fit |> stan_rhat()
heron_brm_speed$fit |> stan_ess()
```

-   **stan_ac**: All below 0.25, all good.
-   **rhat_hist**: Rhat is a **scale reduction factor** measure of convergence between the chains. The closer the values are to 1, the more the chains have converged. Values greater than 1.05 indicate a lack of convergence. There will be an Rhat value for each parameter estimated.
-   **stan_ess:** effective sample size better than previous model, more around 70%

#### **Posterior probability checks**

```{r}
heron_brm_speed |> pp_check(type = 'dens_overlay', ndraws = 100)
heron_brm_speed |> pp_check (type = "error_scatter_avg")
heron_brm_speed |> mcmc_plot(type='violin')
```

#### **dHARMA residuals**

```{r}
library(DHARMa)
heron.resids <- make_brms_dharma_res(heron_brm_speed, integerResponse = TRUE)
testUniformity(heron.resids)
```

```{r}
#remove NA values of predictor variable
heron_t3 <- heron_t3[complete.cases(heron_t3$median_speed),  ]

wrap_elements(~testUniformity(heron.resids))
wrap_elements(~plotResiduals(heron.resids, form = factor(rep(1,nrow(heron_t3))))) 
wrap_elements(~plotResiduals(heron.resids, quantreg = TRUE))   # leave the quartile calculations off if you have a small amount of data
wrap_elements(~testDispersion(heron.resids))
```

### brm- Ub

#### **MCMC**

```{r}
pars <- heron_brm_Ub |> get_variables()  #capture the list of variables
pars <- str_extract(pars, "^b_.*|^sd.*") |> na.omit()
pars

heron_brm_Ub$fit |> stan_trace(pars = pars)
heron_brm_Ub$fit |> stan_ac(pars = pars)
heron_brm_Ub$fit |> stan_rhat()
heron_brm_Ub$fit |> stan_ess()
```

#### **Posterior probability checks**

```{r}
heron_brm_Ub |> pp_check(type = 'dens_overlay', ndraws = 100)
heron_brm_Ub |> pp_check (type = "error_scatter_avg")
heron_brm_Ub |> mcmc_plot(type='violin')
```

#### **dHARMA residuals**

```{r}
library(DHARMa)
heron.resids <- make_brms_dharma_res(heron_brm_Ub, integerResponse = TRUE)
testUniformity(heron.resids)
```

```{r}
wrap_elements(~testUniformity(heron.resids))
wrap_elements(~plotResiduals(heron.resids, form = factor(rep(1,nrow(heron_t3))))) 
wrap_elements(~plotResiduals(heron.resids, quantreg = TRUE))   # leave the quartile calculations off if you have a small amount of data
wrap_elements(~testDispersion(heron.resids))
```

### brm- Wave

#### **MCMC**

```{r}
pars <- heron_brm_wave |> get_variables()  #capture the list of variables
pars <- str_extract(pars, "^b_.*|^sd.*") |> na.omit()
pars

heron_brm_wave$fit |> stan_trace(pars = pars)
heron_brm_wave$fit |> stan_ac(pars = pars)
heron_brm_wave$fit |> stan_rhat()
heron_brm_wave$fit |> stan_ess()
```

#### **Posterior probability checks**

```{r}
heron_brm_wave |> pp_check(type = 'dens_overlay', ndraws = 100)
heron_brm_wave |> pp_check (type = "error_scatter_avg")
heron_brm_wave |> mcmc_plot(type='violin')
```

#### **dHARMA residuals**

```{r}
library(DHARMa)
heron.resids <- make_brms_dharma_res(heron_brm_wave, integerResponse = FALSE)
testUniformity(heron.resids)
```

```{r}
wrap_elements(~testUniformity(heron.resids))
wrap_elements(~plotResiduals(heron.resids, form = factor(rep(1,nrow(heron_t3))))) 
wrap_elements(~plotResiduals(heron.resids, quantreg = TRUE))   # leave the quartile calculations off if you have a small amount of data
wrap_elements(~testDispersion(heron.resids))
```

### brm - turf

#### **MCMC**

```{r}
pars <- heron_brm_turf |> get_variables()  #capture the list of variables
pars <- str_extract(pars, "^b_.*|^sd.*") |> na.omit()

heron_brm_turf$fit |> stan_trace(pars = pars)
heron_brm_turf$fit |> stan_ac(pars = pars)
heron_brm_turf$fit |> stan_rhat()
heron_brm_turf$fit |> stan_ess()
```

#### **Posterior probability checks**

```{r}
heron_brm_turf |> pp_check(type = 'dens_overlay', ndraws = 100)
heron_brm_turf |> pp_check (type = "error_scatter_avg")
heron_brm_turf |> mcmc_plot(type='violin')
```

#### **dHARMA residuals**

```{r}
library(DHARMa)
heron.resids <- make_brms_dharma_res(heron_brm_turf, integerResponse = FALSE)
testUniformity(heron.resids)
```

```{r}
wrap_elements(~testUniformity(heron.resids))
wrap_elements(~plotResiduals(heron.resids, form = factor(rep(1,nrow(heron_t3))))) 
wrap_elements(~plotResiduals(heron.resids, quantreg = TRUE))   # leave the quartile calculations off if you have a small amount of data
wrap_elements(~testDispersion(heron.resids))
```

### brm- PC1

#### **MCMC**

```{r}
pars <- heron_brm_PC1 |> get_variables()  #capture the list of variables
pars <- str_extract(pars, "^b_.*|^sd.*") |> na.omit()


heron_brm_PC1$fit |> stan_trace(pars = pars)
heron_brm_PC1$fit |> stan_ac(pars = pars)
heron_brm_PC1$fit |> stan_rhat()
heron_brm_PC1$fit |> stan_ess()
```

#### **Posterior probability checks**

```{r}
heron_brm_PC1 |> pp_check(type = 'dens_overlay', ndraws = 100)
heron_brm_PC1 |> pp_check (type = "error_scatter_avg")
heron_brm_PC1 |> mcmc_plot(type='violin')
```

#### **dHARMA residuals**

```{r}
library(DHARMa)
heron.resids <- make_brms_dharma_res(heron_brm_PC1, integerResponse = FALSE)
testUniformity(heron.resids)
```

```{r}
wrap_elements(~testUniformity(heron.resids))
wrap_elements(~plotResiduals(heron.resids, form = factor(rep(1,nrow(heron_t3))))) 
wrap_elements(~plotResiduals(heron.resids, quantreg = TRUE))   # leave the quartile calculations off if you have a small amount of data
wrap_elements(~testDispersion(heron.resids))
```

# Further analyses

## Visualization

```{r}
#heron_brm |> conditional_effects() |> plot(points=TRUE)
heron_brm_speed |> conditional_effects() |> plot(points=TRUE)
heron_brm_Ub |> conditional_effects() |> plot(points=TRUE)
heron_brm_turf |> conditional_effects() |> plot(points=TRUE)
heron_brm_wave |> conditional_effects() |> plot(points=TRUE)
heron_brm_PC|> conditional_effects() |> plot(points=TRUE)
```

### Figure 1

```{r partialPlot2h1b, results='markdown', eval=TRUE, mhidden=TRUE, fig.width=8, fig.height=5}

ggpredict(heron_brm_speed, terms = ~median_speed) %>%
   plot(add.data = TRUE)
 

Fig1a <- ggemmeans(heron_brm_speed, terms = ~median_speed) %>%
  plot(add.data = TRUE) 

conditional_effects(heron_brm_speed) |> 
  plot(points = TRUE)

Fig1b <- heron_brm_speed %>% emmeans(~median_speed , type = 'link') %>%
    as.data.frame() %>%
    ggplot(aes(y = emmean, x = median_speed)) +
   # geom_hline(yintercept = c(5,-5), linetype = 'dashed') +
    geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD)) +
    geom_point(data = heron_t3, aes(y = SurvDev),
              # position = position_jitter(width=0.02, height = 0),
               alpha=0.4, color = 'red') +  
     labs(title = "heron Reef", x = "Median Speed (m/s)", y = "Estimated marginal mean - Survival (yield)") +  # Axis labels
  theme_minimal()  # Apply minimal theme

print(Fig1a)
print(Fig1b)

#ggsave("Fig1a - heron Predicted probabilities SurvDev.jpeg", Fig1a, width = 10, height = 6)
#ggsave("Fig1b - heron Estimated marginal means SurvDev.jpeg", Fig1b, width = 10, height = 6)
#saved on 05/04/2024


```

### Figure 2

```{r}
new_data <- data.frame(
  median_speed = median_speed_seq
)

# Extract fitted draws for the new data
#fitted_draws <- add_epred_draws(heron.speed.brm, newdata = new_data, allow_new_levels = TRUE)

fitted_draws <- heron.speed.brm |>
  add_fitted_draws(newdata = new_data, allow_new_levels = TRUE)

summary_stats <- fitted_draws |>
    summarise(
    mean_survival_probability = mean(.value), #calculating the predicted means
    se = sd(.value) / sqrt(n())  # Calculate standard error
  ) |>
  ungroup()


# Plotting the results
Fig2 <- ggplot(summary_stats, aes(x = median_speed_seq, y = mean_survival_probability, group = 1)) +
  geom_line() +  
  geom_point() +  
#  geom_errorbar(aes(ymin = mean_survival_probability - se, ymax = mean_survival_probability + se), 
#                width = 0.1) +  # Set the width of the error bars  
  labs( title = "heron Reef", y = "survival probability", x = "median speed (m/s)") +
  theme_bw() + theme(text = element_text(size = 12)) 

print(Fig2)
#ggsave("Fig2 - heron Survival probabilities.jpeg", Fig2, width = 10, height = 6)
#saved on 05/04/2024
```

# Interpretation

### brm time:

```{r}
heron_brm_time |> summary()
heron_brm_Spp_dev|> summary()
heron_brm_Spp_time|> summary()
heron_brm_time_wave|> summary()
heron_brm_time_Ub|> summary()
heron_brm_time_Speed|> summary()
heron_brm_time_turf|> summary()
heron_brm_time_concrete|> summary()
heron_brm_time_PCA|> summary()
```

### brm t3:

```{r}
heron_brm |> summary()
#heron_brm_t3_Spp_dev|> summary()
#heron_brm_t3_Spp|> summary()
heron_brm_wave|> summary()
heron_brm_Ub|> summary()
heron_brm_speed|> summary()
heron_brm_turf|> summary()
heron_brm_concrete|> summary()
heron_brm_PCA|> summary()
```

```{r}
heron_brm |> r2_loo()
heron_brm_t3_Spp_dev|> r2_loo()
heron_brm_t3_Spp|> r2_loo()
heron_brm_wave|> r2_loo()
heron_brm_Ub|> r2_loo()
heron_brm_speed|> r2_loo()
heron_brm_turf|> r2_loo()
heron_brm_concrete|> r2_loo()
heron_brm_PC|> r2_loo()
```

### speed

```{r}
heron_brm_speed |> summary()
```

```{r}
heron_brm_speed$fit |> tidyMCMC(estimate.method = "median", 
                            conf.int = TRUE, 
                            conf.method = "HPDinterval", 
                            rhat = TRUE, 
                            ess = TRUE, 
                            exponential = TRUE)
```

```{r}
heron_speed_tidy <- heron_brm_speed |> as_draws_df()  |>
  dplyr::select(matches("^b_.*")) |>    # a more sophisticated way of selecting (and searching) for pattersn in our column headers
  mutate(across(everything(), exp)) |>
  summarise_draws("median",            #  for every column calculate the median
                 ~HDInterval::hdi(.x), #  highest density intervals come from a specific package and threfore you need to specify the package it comes from, and therefore you need to put a ~ infront of it, and (.x) 
                  "rhat",               # for every column give me the rhat 
                  "ess_bulk",           # for every column give me the ess_bulk
                 P = ~mean(.x <1),    # what is the probability that there is any effect (100%)
                 P5 = ~mean(.x <0.95),  # what is the probability that there is a 5% decline?
                 P50= ~mean(.x <0.5)) # what is the probability that there is a 50% decline?
  
#RUN IN CONSOLE
#write.xlsx(heron.speed.brm.tidy, file = "data/Heron survival-speed brm tidy_odds ratio.xlsx") #Saving this data for interpretation in a manuscript

```

[**This table is the easiest to describe as your narrative for the biology/ecology of your data.**]{.underline} Also we have now first done the exponential of each number and then summarized this, instead of first summarizing it and then calculating the exponential of it. Therefore, for the Confidence Interval of b_median_current_speed we are now looking for that this range [**does not exceed 1**]{.underline} (as the exponential of zero is 1). Does the interval of \[0.0000- 0.0001489\] includes 1? NO! Therefore we have evidence that our slope decreases with current

### Ub

```{r}
heron_brm_Ub |> summary()
```

### Wave

```{r}
heron_brm_wave |> summary()
```

### Turf

```{r}
heron_brm_turf |> summary()
```

### Concrete

```{r}
heron_brm_concrete |> summary()
```

### R2

```{r}
# Store models in a list
models <- list(
  heron_brm = heron_brm,
  heron_brm_speed = heron_brm_speed,
  heron_brm_wave = heron_brm_wave,
  heron_brm_Ub = heron_brm_Ub,
  heron_brm_turf = heron_brm_turf,
  heron_brm_concrete = heron_brm_concrete,
  heron_brm_PC1 = heron_brm_PC1
)

# Apply operations and store results in a list
results <- lapply(models, function(model) {
  model |>
    bayes_R2(summary = FALSE) |>
    median_hdci()
})

# Print the list of results
print(results)

```

```{r}
heron_brm_speed |> 
  as_draws_df() |>
  dplyr::select(matches("^b_.*")) |>
  mutate(LD50 = -1*b_Intercept / b_median_speed) |>
  median_hdci(LD50)
```
