#heron_brm |> conditional_effects() |> plot(points=TRUE)
heron_brm_speed |> conditional_effects() |> plot(points=TRUE)
heron_brm_speed1 |> conditional_effects() |> plot(points=TRUE)
heron_brm_Ub |> conditional_effects() |> plot(points=TRUE)
heron_brm_turf |> conditional_effects() |> plot(points=TRUE)
heron_brm_wave |> conditional_effects() |> plot(points=TRUE)
heron_brm_PC1 |> conditional_effects() |> plot(points=TRUE)
ggpredict(heron_brm_speed, terms = ~median_speed) %>%
plot(add.data = TRUE)
Fig1a <- ggemmeans(heron_brm_speed, terms = ~median_speed) %>%
plot(add.data = TRUE)
conditional_effects(heron_brm_speed) |>
plot(points = TRUE)
Fig1b <- heron_brm_speed %>% emmeans(~median_speed , type = 'link') %>%
as.data.frame() %>%
ggplot(aes(y = emmean, x = median_speed)) +
# geom_hline(yintercept = c(5,-5), linetype = 'dashed') +
geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD)) +
geom_point(data = heron_t2, aes(y = SurvDev),
# position = position_jitter(width=0.02, height = 0),
alpha=0.4, color = 'red') +
labs(title = "heron Reef", x = "Median Speed (m/s)", y = "Estimated marginal mean - Survival (yield)") +  # Axis labels
theme_minimal()  # Apply minimal theme
print(Fig1a)
print(Fig1b)
#ggsave("Fig1a - heron Predicted probabilities SurvDev.jpeg", Fig1a, width = 10, height = 6)
#ggsave("Fig1b - heron Estimated marginal means SurvDev.jpeg", Fig1b, width = 10, height = 6)
#saved on 05/04/2024
heron_brm_speed |> summary()
heron_speed_tidy <- heron_brm_speed |> as_draws_df()  |>
dplyr::select(matches("^b_.*")) |>    # a more sophisticated way of selecting (and searching) for pattersn in our column headers
mutate(across(everything(), exp)) |>
summarise_draws("median",            #  for every column calculate the median
~HDInterval::hdi(.x), #  highest density intervals come from a specific package and threfore you need to specify the package it comes from, and therefore you need to put a ~ infront of it, and (.x)
"rhat",               # for every column give me the rhat
"ess_bulk",           # for every column give me the ess_bulk
P = ~mean(.x <1),    # what is the probability that there is any effect (100%)
P5 = ~mean(.x <0.95),  # what is the probability that there is a 5% decline?
P50= ~mean(.x <0.5)) # what is the probability that there is a 50% decline?
#RUN IN CONSOLE
#write.xlsx(heron.speed.brm.tidy, file = "data/Heron survival-speed brm tidy_odds ratio.xlsx") #Saving this data for interpretation in a manuscript
heron_speed_tidy <- heron_brm_speed |> as_draws_df()  |>
dplyr::select(matches("^b_.*")) |>    # a more sophisticated way of selecting (and searching) for pattersn in our column headers
mutate(across(everything(), exp)) |>
summarise_draws("median",            #  for every column calculate the median
~HDInterval::hdi(.x), #  highest density intervals come from a specific package and threfore you need to specify the package it comes from, and therefore you need to put a ~ infront of it, and (.x)
"rhat",               # for every column give me the rhat
"ess_bulk",           # for every column give me the ess_bulk
P = ~mean(.x <1),    # what is the probability that there is any effect (100%)
P5 = ~mean(.x <0.95),  # what is the probability that there is a 5% decline?
P50= ~mean(.x <0.5)) # what is the probability that there is a 50% decline?
#RUN IN CONSOLE
#write.xlsx(heron.speed.brm.tidy, file = "data/Heron survival-speed brm tidy_odds ratio.xlsx") #Saving this data for interpretation in a manuscript
heron_speed_tidy
heron_speed_tidy
heron_brm_speed |>
bayes_R2(summary = FALSE) |>
median_hdci()
heron_brm_speed |>
as_draws_df() |>
dplyr::select(matches("^b_.*")) |>
mutate(LD50 = -1*b_Intercept / b_median_speed) |>
median_hdci(LD50)
heron_brm_speed |>
bayes_R2(summary = FALSE) |>
median_hdci()
heron_brm_speed |>
bayes_R2(summary = FALSE) |>
median_hdci()
heron_brm_wave |>
bayes_R2(summary = FALSE) |>
median_hdci()
heron_brm_Ub |>
bayes_R2(summary = FALSE) |>
median_hdci()
heron_brm |>
bayes_R2(summary = FALSE) |>
median_hdci()
heron_brm_speed |>
bayes_R2(summary = FALSE) |>
median_hdci()
heron_brm_wave |>
bayes_R2(summary = FALSE) |>
median_hdci()
heron_brm_Ub |>
bayes_R2(summary = FALSE) |>
median_hdci()
heron_brm_turf |>
bayes_R2(summary = FALSE) |>
median_hdci()
heron_brm_concrete |>
bayes_R2(summary = FALSE) |>
median_hdci()
heron_brm_PC1 |>
bayes_R2(summary = FALSE) |>
median_hdci()
# Store models in a list
models <- list(
heron_brm = heron_brm,
heron_brm_speed = heron_brm_speed,
heron_brm_wave = heron_brm_wave,
heron_brm_Ub = heron_brm_Ub,
heron_brm_turf = heron_brm_turf,
heron_brm_concrete = heron_brm_concrete,
heron_brm_PC1 = heron_brm_PC1
)
# Apply operations and store results in a list
results <- lapply(models, function(model) {
model |>
bayes_R2(summary = FALSE) |>
median_hdci()
})
# Print the list of results
print(results)
heron_brm_Ub |> summary()
heron_brm <- brm(heron_form,
data=heron_t2,
prior = priors,
sample_prior = 'yes',
iter = 5000,
warmup = 1000,
chains = 3, cores = 3,
thin = 5,
refresh = 0,
control = list(adapt_delta = 0.9),
backend = "rstan")
# To save the model use >>
#save(heron_brm, file = "scripts/models/heron_brm.RData")
save(heron_brm, file = "scripts/models/heron_brm.RData")
heron_brm_speed <- brm(heron_form_speed,
data=heron_t2,
prior = priors_speed,
sample_prior = 'yes',
iter = 5000,
warmup = 1000,
chains = 3, cores = 3,
thin = 5,
refresh = 0,
control = list(adapt_delta = 0.9),
backend = "rstan")
heron_brm_Ub <- brm(heron_form_Ub,
data=heron_t2,
prior = priors_Ub,
sample_prior = 'yes',
iter = 5000,
warmup = 1000,
chains = 3, cores = 3,
thin = 5,
refresh = 0,
control = list(adapt_delta = 0.9),
backend = "rstan")
# Save the model
#save(heron_brm_Ub, file = "scripts/models/heron_brm_Ub.RData")
save(heron_brm_Ub, file = "scripts/models/heron_brm_Ub.RData")
heron_brm_wave <- brm(heron_form_Wave,
data=heron_t2,
prior = priors_wave,
sample_prior = 'yes',
iter = 5000,
warmup = 1000,
chains = 3, cores = 3,
thin = 5,
refresh = 0,
control = list(adapt_delta = 0.9),
backend = "rstan")
# Save the model
#save(heron_brm_wave, file = "scripts/models/heron_brm_wave.RData")
save(heron_brm_wave, file = "scripts/models/heron_brm_wave.RData")
heron_brm_turf <- brm(heron_form_turf,
data=heron_t2,
prior = priors_turf,
sample_prior = 'yes',
iter = 5000,
warmup = 1000,
chains = 3, cores = 3,
thin = 5,
refresh = 0,
control = list(adapt_delta = 0.9),
backend = "rstan")
2.5 * sd(heron_t2$SurvDev, na.rm = TRUE)/sd(heron_t2$sedturf_t2, na.rm = TRUE)
priors_turf <- prior(normal(0, 1.7), class = "Intercept") +
prior(normal(0,0.25), class = "b")  +
prior(student_t(3, 0, 1.5), class = 'sd')
2.5 * sd(heron_t2$SurvDev, na.rm = TRUE)/sd(heron_t2$sedconcrete_t2, na.rm = TRUE)
priors_concrete <- prior(normal(0, 1.7), class = "Intercept") +
prior(normal(0,1.2), class = "b")  +
prior(student_t(3, 0, 1.5), class = 'sd')
heron_brm_turf <- brm(heron_form_turf,
data=heron_t2,
prior = priors_turf,
sample_prior = 'yes',
iter = 5000,
warmup = 1000,
chains = 3, cores = 3,
thin = 5,
refresh = 0,
control = list(adapt_delta = 0.9),
backend = "rstan")
# Save the model
#save(heron_brm_turf, file = "scripts/models/heron_brm_turf.RData")
heron_brm_concrete <- brm(heron_form_concrete,
data=heron_t2,
prior = priors_concrete,
sample_prior = 'yes',
iter = 5000,
warmup = 1000,
chains = 3, cores = 3,
thin = 5,
refresh = 0,
control = list(adapt_delta = 0.9),
backend = "rstan")
# Save the model
#save(heron_brm_concrete, file = "scripts/models/heron_brm_concrete.RData")
save(heron_brm_concrete, file = "scripts/models/heron_brm_concrete.RData")
save(heron_brm_turf, file = "scripts/models/heron_brm_turf.RData")
heron_brm_PC1 <- brm(heron_form_PC1,
data=heron_t2,
prior = priors_PC1,
sample_prior = 'yes',
iter = 5000,
warmup = 1000,
chains = 3, cores = 3,
thin = 5,
refresh = 0,
control = list(adapt_delta = 0.9),
backend = "rstan")
# Save the model
#save(heron_brm_PC1, file = "scripts/models/heron_brm_PC1.RData")
save(heron_brm_PC1, file = "scripts/models/heron_brm_PC1.RData")
heron_brm_Ub |> summary()
heron_brm_wave |> summary()
heron_brm_wave |> summary()
heron_brm_turf |> summary()
heron_brm_concrete |> summary()
#| label: libraries
#| output: false
#| eval: true
#| warning: false
#| message: false
#| cache: false
library(tidyverse)  #for data wrangling etc
library(rstanarm)   #for fitting models in STAN
#library(cmdstanr)   #for cmdstan --> does not work on AIMS computers
library(brms)       #for fitting models in STAN
library(standist)   #for exploring distributions
library(coda)       #for diagnostics
library(bayesplot)  #for diagnostics
library(ggmcmc)     #for MCMC diagnostics
library(DHARMa)     #for residual diagnostics
library(rstan)      #for interfacing with STAN
library(emmeans)    #for marginal means etc
library(broom)      #for tidying outputs
library(tidybayes)  #for more tidying outputs
library(HDInterval) #for HPD intervals
library(ggeffects)  #for partial plots
library(broom.mixed)#for summarising models
library(posterior)  #for posterior draws
library(ggeffects)  #for partial effects plots
library(patchwork)  #for multi-panel figures
library(bayestestR) #for ROPE
library(see)        #for some plots
library(readxl)     #to load excel documents
library(easystats)     #framework for stats, modelling and visualisation
#library(INLA)       #for approximate Bayes
library(openxlsx)    # to write excel documents
#library(INLAutils)  #for additional INLA outputs
theme_set(theme_grey()) #put the default ggplot theme back
source('helperFunctions.R')
survival <- read_excel("data/YEAR1_Survival.xlsx", na ="")
environment <- read_excel ("data/YEAR1 Benthic Environment ReefDev.xlsx", na="")
survival <- survival |>
select(-c(ID, Observer, CensusT, DeploymentDate, CensusDate, Device_ID, NoRecruits))
survival <- survival |>
select(-c(ID, Observer, CensusT, DeploymentDate, CensusDate, Device_ID, NoRecruits))
moore_surv <- survival |> filter (Reef == "Moore",
Census == "t5",
Tab_ID == 1) |>
select(-c(Tab_ID, SurvTab, Spp))
moore_env <- environment |>
filter (Reef == "Moore") |>
select(-c(Reef1, Device_ID))
moore_surv <- survival |> filter (Reef == "Moore",
Census == "t6",
Tab_ID == 1) |>
select(-c(Tab_ID, SurvTab, Spp))
moore_env <- environment |>
filter (Reef == "Moore") |>
select(-c(Reef1, Device_ID))
moore_t2 <- merge(moore_env, moore_surv, by = c("Reef", "Site", "ReefDev"), all = TRUE)
#free up space
remove(moore_surv, moore_env)
# Remove rows with missing values
moore_t2$SurvDev <- as.numeric(moore_t2$SurvDev)
moore_t2 <- moore_t2[complete.cases(moore_t2$SurvDev),  ]
moore_t2 <- moore_t2 |> select(-c(sedturf_t5, sedconcrete_t5))
moore_surv <- survival |> filter (Reef == "Moore",
Census == "t6",
Tab_ID == 1) |>
select(-c(Tab_ID, SurvTab, Spp))
moore_env <- environment |>
filter (Reef == "Moore") |>
select(-c(Reef1, Device_ID))
moore_t5 <- merge(moore_env, moore_surv, by = c("Reef", "Site", "ReefDev"), all = TRUE)
#free up space
remove(moore_surv, moore_env)
# Remove rows with missing values
moore_t5$SurvDev <- as.numeric(moore_t5$SurvDev)
moore_t5 <- moore_t5[complete.cases(moore_t5$SurvDev),  ]
moore_t5 <- moore_t5 |> select(-c(sedturf_t2, sedconcrete_t2))
remove(moore_t2)
View(moore_t5)
moore_t5 <- moore_t5[complete.cases(moore_t5$PC1),  ]
library(lme4)
moore_t5$Site <- as.factor(moore_t5$Site)
moore_t5$ReefDev<- as.factor(moore_t5$ReefDev)
moore_glmer1<- glmer(SurvDev ~ (1|Site) + (1|ReefDev), data=moore_t5, family = binomial(link = "logit")) #allowing for random intercepts but not random slopes --> accounting for potential variability in survival beteeen different sites and devices, but assuming that the effect of device on  survival is constant across different sites.
moore_glmer2<- glmer(SurvDev ~ Ub_avrg + (1|Site) + (1|ReefDev), data=moore_t5, family = binomial(link = "logit"))
moore_glmer3<- glmer(SurvDev ~ WaveEnergyLevel + (1|Site) + (1|ReefDev), data=moore_t5, family = binomial(link = "logit"))
moore_glmer4<- glmer(SurvDev ~ median_speed + (1|Site) + (1|ReefDev), data=moore_t5, family = binomial(link = "logit"))
moore_glmer5<- glmer(SurvDev ~ sedturf_t5 + (1|Site) + (1|ReefDev), data=moore_t5, family = binomial(link = "logit"))
summary(moore_glmer1)
summary(moore_glmer2)
summary(moore_glmer3)
summary(moore_glmer4)
summary(moore_glmer5)
AIC(mooreSpp_glmer1, moore_glmer1, moore_glmer2, moore_glmer3, moore_glmer4, moore_glmer5)
library(lme4)
moore_t5$Site <- as.factor(moore_t5$Site)
moore_t5$ReefDev<- as.factor(moore_t5$ReefDev)
moore_glmer1<- glmer(SurvDev ~ (1|Site) + (1|ReefDev), data=moore_t5, family = binomial(link = "logit")) #allowing for random intercepts but not random slopes --> accounting for potential variability in survival beteeen different sites and devices, but assuming that the effect of device on  survival is constant across different sites.
moore_glmer2<- glmer(SurvDev ~ Ub_avrg + (1|Site) + (1|ReefDev), data=moore_t5, family = binomial(link = "logit"))
moore_glmer3<- glmer(SurvDev ~ WaveEnergyLevel + (1|Site) + (1|ReefDev), data=moore_t5, family = binomial(link = "logit"))
moore_glmer4<- glmer(SurvDev ~ median_speed + (1|Site) + (1|ReefDev), data=moore_t5, family = binomial(link = "logit"))
moore_glmer5<- glmer(SurvDev ~ sedturf_t5 + (1|Site) + (1|ReefDev), data=moore_t5, family = binomial(link = "logit"))
summary(moore_glmer1)
summary(moore_glmer2)
summary(moore_glmer3)
summary(moore_glmer4)
summary(moore_glmer5)
AIC(moore_glmer1, moore_glmer2, moore_glmer3, moore_glmer4, moore_glmer5)
AIC(moore_glmer1, moore_glmer2, moore_glmer3, moore_glmer4, moore_glmer5)
ggplot(data=moore_t5, aes(y = SurvDev, x = median_speed)) +
geom_point(position = position_jitter(width = 0.2, height = 0)) +
geom_smooth(method="lm")
ggplot(data=moore_t5, aes(y = SurvDev, x = median_speed)) +
geom_point(position = position_jitter(width = 0.2, height = 0)) +
geom_smooth(method="lm", formula = y~poly(x,3), se = FALSE)
#with facetwrap by site
ggplot(data=moore_t5, aes(y = SurvDev, x = median_speed)) +
geom_point(position = position_jitter(width = 0.2, height = 0)) +
facet_wrap(~Site) +
geom_smooth(method="lm")
ggplot(data=moore_t5, aes(y = SurvDev, x = WaveEnergyLevel)) +
geom_point(position = position_jitter(width = 0.2, height = 0)) +
geom_smooth(method="lm")
ggplot(data=moore_t5, aes(y = SurvDev, x = WaveEnergyLevel)) +
geom_point(position = position_jitter(width = 0.2, height = 0)) +
geom_smooth(method="lm", formula = y~poly(x,3), se = FALSE)
#with facetwrap by site
ggplot(data=moore_t5, aes(y = SurvDev, x = WaveEnergyLevel)) +
geom_point(position = position_jitter(width = 0.2, height = 0)) +
facet_wrap(~Site) +
geom_smooth(method="lm")
moore_t5 <- moore_t5 |> mutate(Site = factor(Site),
ReefDev = factor(ReefDev))
moore_form <- bf(SurvDev ~ (1|Site) + (1|ReefDev), family = bernoulli(link='logit'))
moore_form_speed <- bf(SurvDev ~ median_speed +    (1|Site) + (1|ReefDev), family = bernoulli(link='logit'))
moore_form_Ub <-    bf(SurvDev ~ Ub_avrg +         (1|Site) + (1|ReefDev), family = bernoulli(link='logit'))
moore_form_turf <-   bf(SurvDev ~ sedturf_t5 +     (1|Site) + (1|ReefDev), family = bernoulli(link='logit'))
moore_form_concrete <-bf(SurvDev ~ sedconcrete_t5 +(1|Site) + (1|ReefDev), family = bernoulli(link='logit'))
moore_form_Wave <-  bf(SurvDev ~ WaveEnergyLevel + (1|Site) + (1|ReefDev), family = bernoulli(link='logit'))
moore_form_PC1 <-   bf(SurvDev ~ PC1 +             (1|Site) + (1|ReefDev), family = bernoulli(link='logit'))
priors <- prior(normal(0, 1.7), class = "Intercept") +
prior(student_t(3, 0, 1.5), class = 'sd')
2.5 * sd(moore_t5$SurvDev, na.rm = TRUE)/sd(moore_t5$median_speed, na.rm = TRUE)
priors_speed <- prior(normal(0, 1.7), class = "Intercept") +
prior(normal(0,30), class = "b")  +
prior(student_t(3, 0, 1.5), class = 'sd')
2.5 * sd(moore_t5$SurvDev, na.rm = TRUE)/sd(moore_t5$median_speed, na.rm = TRUE)
priors_speed <- prior(normal(0, 1.7), class = "Intercept") +
prior(normal(0,57), class = "b")  +
prior(student_t(3, 0, 1.5), class = 'sd')
2.5 * sd(moore_t5$SurvDev, na.rm = TRUE)/sd(moore_t5$Ub_avrg, na.rm = TRUE)
priors_Ub <- prior(normal(0, 1.7), class = "Intercept") +
prior(normal(0,6), class = "b")  +
prior(student_t(3, 0, 1.5), class = 'sd')
2.5 * sd(moore_t5$SurvDev, na.rm = TRUE)/sd(moore_t5$Ub_avrg, na.rm = TRUE)
priors_Ub <- prior(normal(0, 1.7), class = "Intercept") +
prior(normal(0,8), class = "b")  +
prior(student_t(3, 0, 1.5), class = 'sd')
2.5 * sd(moore_t5$SurvDev, na.rm = TRUE)/sd(moore_t5$sedturf_t5, na.rm = TRUE)
priors_turf <- prior(normal(0, 1.7), class = "Intercept") +
prior(normal(0,0.25), class = "b")  +
prior(student_t(3, 0, 1.5), class = 'sd')
2.5 * sd(moore_t5$SurvDev, na.rm = TRUE)/sd(moore_t5$sedturf_t5, na.rm = TRUE)
priors_turf <- prior(normal(0, 1.7), class = "Intercept") +
prior(normal(0,1.6), class = "b")  +
prior(student_t(3, 0, 1.5), class = 'sd')
2.5 * sd(moore_t5$SurvDev, na.rm = TRUE)/sd(moore_t5$sedconcrete_t5, na.rm = TRUE)
priors_concrete <- prior(normal(0, 1.7), class = "Intercept") +
prior(normal(0,1.2), class = "b")  +
prior(student_t(3, 0, 1.5), class = 'sd')
2.5 * sd(moore_t5$SurvDev, na.rm = TRUE)/sd(moore_t5$sedconcrete_t5, na.rm = TRUE)
priors_concrete <- prior(normal(0, 1.7), class = "Intercept") +
prior(normal(0,4), class = "b")  +
prior(student_t(3, 0, 1.5), class = 'sd')
2.5 * sd(moore_t5$SurvDev, na.rm = TRUE)/sd(moore_t5$WaveEnergyLevel, na.rm = TRUE)
priors_wave <- prior(normal(0, 1.7), class = "Intercept") +
prior(normal(0,1), class = "b")  +
prior(student_t(3, 0, 1.5), class = 'sd')
2.5 * sd(moore_t5$SurvDev, na.rm = TRUE)/sd(moore_t5$PC1, na.rm = TRUE)
priors_PC1 <- prior(normal(0, 1.7), class = "Intercept") +
prior(normal(0,8), class = "b")  +
prior(student_t(3, 0, 1.5), class = 'sd')
moore_brm <- brm(moore_form,
data=moore_t5,
prior = priors,
sample_prior = 'yes',
iter = 5000,
warmup = 1000,
chains = 3, cores = 3,
thin = 5,
refresh = 0,
control = list(adapt_delta = 0.99),
backend = "rstan")
# To save the model use >>
#save(moore_brm, file = "scripts/models/moore_brm.RData")
save(moore_brm, file = "scripts/models/moore_brm.RData")
moore_brm_speed <- brm(moore_form_speed,
data=moore_t5,
prior = priors_speed,
sample_prior = 'yes',
iter = 5000,
warmup = 1000,
chains = 3, cores = 3,
thin = 5,
refresh = 0,
control = list(adapt_delta = 0.9),
backend = "rstan")
# Save the model
#save(moore_brm_speed, file = "scripts/models/moore_brm_speed.RData")
save(moore_brm_speed, file = "scripts/models/moore_brm_speed.RData")
moore_brm_Ub <- brm(moore_form_Ub,
data=moore_t5,
prior = priors_Ub,
sample_prior = 'yes',
iter = 5000,
warmup = 1000,
chains = 3, cores = 3,
thin = 5,
refresh = 0,
control = list(adapt_delta = 0.9),
backend = "rstan")
# Save the model
#save(moore_brm_Ub, file = "scripts/models/moore_brm_Ub.RData")
save(moore_brm_Ub, file = "scripts/models/moore_brm_Ub.RData")
moore_brm_wave <- brm(moore_form_Wave,
data=moore_t5,
prior = priors_wave,
sample_prior = 'yes',
iter = 5000,
warmup = 1000,
chains = 3, cores = 3,
thin = 5,
refresh = 0,
control = list(adapt_delta = 0.99),
backend = "rstan")
# Save the model
#save(moore_brm_wave, file = "scripts/models/moore_brm_wave.RData")
save(moore_brm_wave, file = "scripts/models/moore_brm_wave.RData")
moore_brm_turf <- brm(moore_form_turf,
data=moore_t5,
prior = priors_turf,
sample_prior = 'yes',
iter = 5000,
warmup = 1000,
chains = 3, cores = 3,
thin = 5,
refresh = 0,
control = list(adapt_delta = 0.9),
backend = "rstan")
# Save the model
#save(moore_brm_turf, file = "scripts/models/moore_brm_turf.RData")
save(moore_brm_turf, file = "scripts/models/moore_brm_turf.RData")
moore_brm_concrete <- brm(moore_form_concrete,
data=moore_t5,
prior = priors_concrete,
sample_prior = 'yes',
iter = 5000,
warmup = 1000,
chains = 3, cores = 3,
thin = 5,
refresh = 0,
control = list(adapt_delta = 0.9),
backend = "rstan")
# Save the model
#save(moore_brm_concrete, file = "scripts/models/moore_brm_concrete.RData")
save(moore_brm_concrete, file = "scripts/models/moore_brm_concrete.RData")
moore_brm_PC1 <- brm(moore_form_PC1,
data=moore_t5,
prior = priors_PC1,
sample_prior = 'yes',
iter = 5000,
warmup = 1000,
chains = 3, cores = 3,
thin = 5,
refresh = 0,
control = list(adapt_delta = 0.9),
backend = "rstan")
# Save the model
#save(moore_brm_PC1, file = "scripts/models/moore_brm_PC1.RData")
save(moore_brm_PC1, file = "scripts/models/moore_brm_PC1.RData")
